// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/duc-cnzj/mars/api/v5/mars"
	"github.com/duc-cnzj/mars/api/v5/types"
	"github.com/duc-cnzj/mars/api/v5/websocket"
	"github.com/duc-cnzj/mars/v5/internal/ent/accesstoken"
	"github.com/duc-cnzj/mars/v5/internal/ent/cachelock"
	"github.com/duc-cnzj/mars/v5/internal/ent/changelog"
	"github.com/duc-cnzj/mars/v5/internal/ent/dbcache"
	"github.com/duc-cnzj/mars/v5/internal/ent/event"
	"github.com/duc-cnzj/mars/v5/internal/ent/favorite"
	"github.com/duc-cnzj/mars/v5/internal/ent/file"
	"github.com/duc-cnzj/mars/v5/internal/ent/namespace"
	"github.com/duc-cnzj/mars/v5/internal/ent/predicate"
	"github.com/duc-cnzj/mars/v5/internal/ent/project"
	"github.com/duc-cnzj/mars/v5/internal/ent/repo"
	"github.com/duc-cnzj/mars/v5/internal/ent/schema/schematype"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccessToken = "AccessToken"
	TypeCacheLock   = "CacheLock"
	TypeChangelog   = "Changelog"
	TypeDBCache     = "DBCache"
	TypeEvent       = "Event"
	TypeFavorite    = "Favorite"
	TypeFile        = "File"
	TypeNamespace   = "Namespace"
	TypeProject     = "Project"
	TypeRepo        = "Repo"
)

// AccessTokenMutation represents an operation that mutates the AccessToken nodes in the graph.
type AccessTokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	token         *string
	usage         *string
	email         *string
	expired_at    *time.Time
	last_used_at  *time.Time
	user_info     *schematype.UserInfo
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AccessToken, error)
	predicates    []predicate.AccessToken
}

var _ ent.Mutation = (*AccessTokenMutation)(nil)

// accesstokenOption allows management of the mutation configuration using functional options.
type accesstokenOption func(*AccessTokenMutation)

// newAccessTokenMutation creates new mutation for the AccessToken entity.
func newAccessTokenMutation(c config, op Op, opts ...accesstokenOption) *AccessTokenMutation {
	m := &AccessTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessTokenID sets the ID field of the mutation.
func withAccessTokenID(id int) accesstokenOption {
	return func(m *AccessTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessToken
		)
		m.oldValue = func(ctx context.Context) (*AccessToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessToken sets the old AccessToken of the mutation.
func withAccessToken(node *AccessToken) accesstokenOption {
	return func(m *AccessTokenMutation) {
		m.oldValue = func(context.Context) (*AccessToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccessTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccessTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccessTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccessTokenMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccessTokenMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccessTokenMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccessTokenMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccessTokenMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccessTokenMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[accesstoken.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccessTokenMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccessTokenMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, accesstoken.FieldDeletedAt)
}

// SetToken sets the "token" field.
func (m *AccessTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AccessTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AccessTokenMutation) ResetToken() {
	m.token = nil
}

// SetUsage sets the "usage" field.
func (m *AccessTokenMutation) SetUsage(s string) {
	m.usage = &s
}

// Usage returns the value of the "usage" field in the mutation.
func (m *AccessTokenMutation) Usage() (r string, exists bool) {
	v := m.usage
	if v == nil {
		return
	}
	return *v, true
}

// OldUsage returns the old "usage" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUsage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsage: %w", err)
	}
	return oldValue.Usage, nil
}

// ResetUsage resets all changes to the "usage" field.
func (m *AccessTokenMutation) ResetUsage() {
	m.usage = nil
}

// SetEmail sets the "email" field.
func (m *AccessTokenMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AccessTokenMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccessTokenMutation) ResetEmail() {
	m.email = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *AccessTokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *AccessTokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *AccessTokenMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[accesstoken.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *AccessTokenMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *AccessTokenMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, accesstoken.FieldExpiredAt)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *AccessTokenMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *AccessTokenMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *AccessTokenMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[accesstoken.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *AccessTokenMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *AccessTokenMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, accesstoken.FieldLastUsedAt)
}

// SetUserInfo sets the "user_info" field.
func (m *AccessTokenMutation) SetUserInfo(si schematype.UserInfo) {
	m.user_info = &si
}

// UserInfo returns the value of the "user_info" field in the mutation.
func (m *AccessTokenMutation) UserInfo() (r schematype.UserInfo, exists bool) {
	v := m.user_info
	if v == nil {
		return
	}
	return *v, true
}

// OldUserInfo returns the old "user_info" field's value of the AccessToken entity.
// If the AccessToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessTokenMutation) OldUserInfo(ctx context.Context) (v schematype.UserInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserInfo: %w", err)
	}
	return oldValue.UserInfo, nil
}

// ClearUserInfo clears the value of the "user_info" field.
func (m *AccessTokenMutation) ClearUserInfo() {
	m.user_info = nil
	m.clearedFields[accesstoken.FieldUserInfo] = struct{}{}
}

// UserInfoCleared returns if the "user_info" field was cleared in this mutation.
func (m *AccessTokenMutation) UserInfoCleared() bool {
	_, ok := m.clearedFields[accesstoken.FieldUserInfo]
	return ok
}

// ResetUserInfo resets all changes to the "user_info" field.
func (m *AccessTokenMutation) ResetUserInfo() {
	m.user_info = nil
	delete(m.clearedFields, accesstoken.FieldUserInfo)
}

// Where appends a list predicates to the AccessTokenMutation builder.
func (m *AccessTokenMutation) Where(ps ...predicate.AccessToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccessToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccessToken).
func (m *AccessTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessTokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, accesstoken.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accesstoken.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, accesstoken.FieldDeletedAt)
	}
	if m.token != nil {
		fields = append(fields, accesstoken.FieldToken)
	}
	if m.usage != nil {
		fields = append(fields, accesstoken.FieldUsage)
	}
	if m.email != nil {
		fields = append(fields, accesstoken.FieldEmail)
	}
	if m.expired_at != nil {
		fields = append(fields, accesstoken.FieldExpiredAt)
	}
	if m.last_used_at != nil {
		fields = append(fields, accesstoken.FieldLastUsedAt)
	}
	if m.user_info != nil {
		fields = append(fields, accesstoken.FieldUserInfo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accesstoken.FieldCreatedAt:
		return m.CreatedAt()
	case accesstoken.FieldUpdatedAt:
		return m.UpdatedAt()
	case accesstoken.FieldDeletedAt:
		return m.DeletedAt()
	case accesstoken.FieldToken:
		return m.Token()
	case accesstoken.FieldUsage:
		return m.Usage()
	case accesstoken.FieldEmail:
		return m.Email()
	case accesstoken.FieldExpiredAt:
		return m.ExpiredAt()
	case accesstoken.FieldLastUsedAt:
		return m.LastUsedAt()
	case accesstoken.FieldUserInfo:
		return m.UserInfo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accesstoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accesstoken.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accesstoken.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case accesstoken.FieldToken:
		return m.OldToken(ctx)
	case accesstoken.FieldUsage:
		return m.OldUsage(ctx)
	case accesstoken.FieldEmail:
		return m.OldEmail(ctx)
	case accesstoken.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	case accesstoken.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case accesstoken.FieldUserInfo:
		return m.OldUserInfo(ctx)
	}
	return nil, fmt.Errorf("unknown AccessToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accesstoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accesstoken.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accesstoken.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case accesstoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case accesstoken.FieldUsage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsage(v)
		return nil
	case accesstoken.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case accesstoken.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	case accesstoken.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case accesstoken.FieldUserInfo:
		v, ok := value.(schematype.UserInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserInfo(v)
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccessToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(accesstoken.FieldDeletedAt) {
		fields = append(fields, accesstoken.FieldDeletedAt)
	}
	if m.FieldCleared(accesstoken.FieldExpiredAt) {
		fields = append(fields, accesstoken.FieldExpiredAt)
	}
	if m.FieldCleared(accesstoken.FieldLastUsedAt) {
		fields = append(fields, accesstoken.FieldLastUsedAt)
	}
	if m.FieldCleared(accesstoken.FieldUserInfo) {
		fields = append(fields, accesstoken.FieldUserInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessTokenMutation) ClearField(name string) error {
	switch name {
	case accesstoken.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case accesstoken.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	case accesstoken.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case accesstoken.FieldUserInfo:
		m.ClearUserInfo()
		return nil
	}
	return fmt.Errorf("unknown AccessToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessTokenMutation) ResetField(name string) error {
	switch name {
	case accesstoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accesstoken.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accesstoken.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case accesstoken.FieldToken:
		m.ResetToken()
		return nil
	case accesstoken.FieldUsage:
		m.ResetUsage()
		return nil
	case accesstoken.FieldEmail:
		m.ResetEmail()
		return nil
	case accesstoken.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	case accesstoken.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case accesstoken.FieldUserInfo:
		m.ResetUserInfo()
		return nil
	}
	return fmt.Errorf("unknown AccessToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AccessToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AccessToken edge %s", name)
}

// CacheLockMutation represents an operation that mutates the CacheLock nodes in the graph.
type CacheLockMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	owner         *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CacheLock, error)
	predicates    []predicate.CacheLock
}

var _ ent.Mutation = (*CacheLockMutation)(nil)

// cachelockOption allows management of the mutation configuration using functional options.
type cachelockOption func(*CacheLockMutation)

// newCacheLockMutation creates new mutation for the CacheLock entity.
func newCacheLockMutation(c config, op Op, opts ...cachelockOption) *CacheLockMutation {
	m := &CacheLockMutation{
		config:        c,
		op:            op,
		typ:           TypeCacheLock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCacheLockID sets the ID field of the mutation.
func withCacheLockID(id int) cachelockOption {
	return func(m *CacheLockMutation) {
		var (
			err   error
			once  sync.Once
			value *CacheLock
		)
		m.oldValue = func(ctx context.Context) (*CacheLock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CacheLock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCacheLock sets the old CacheLock of the mutation.
func withCacheLock(node *CacheLock) cachelockOption {
	return func(m *CacheLockMutation) {
		m.oldValue = func(context.Context) (*CacheLock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CacheLockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CacheLockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CacheLockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CacheLockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CacheLock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *CacheLockMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *CacheLockMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the CacheLock entity.
// If the CacheLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CacheLockMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *CacheLockMutation) ResetKey() {
	m.key = nil
}

// SetOwner sets the "owner" field.
func (m *CacheLockMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *CacheLockMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the CacheLock entity.
// If the CacheLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CacheLockMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *CacheLockMutation) ResetOwner() {
	m.owner = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *CacheLockMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *CacheLockMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the CacheLock entity.
// If the CacheLock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CacheLockMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *CacheLockMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[cachelock.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *CacheLockMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[cachelock.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *CacheLockMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, cachelock.FieldExpiredAt)
}

// Where appends a list predicates to the CacheLockMutation builder.
func (m *CacheLockMutation) Where(ps ...predicate.CacheLock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CacheLockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CacheLockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CacheLock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CacheLockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CacheLockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CacheLock).
func (m *CacheLockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CacheLockMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, cachelock.FieldKey)
	}
	if m.owner != nil {
		fields = append(fields, cachelock.FieldOwner)
	}
	if m.expired_at != nil {
		fields = append(fields, cachelock.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CacheLockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cachelock.FieldKey:
		return m.Key()
	case cachelock.FieldOwner:
		return m.Owner()
	case cachelock.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CacheLockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cachelock.FieldKey:
		return m.OldKey(ctx)
	case cachelock.FieldOwner:
		return m.OldOwner(ctx)
	case cachelock.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown CacheLock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CacheLockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cachelock.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case cachelock.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case cachelock.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown CacheLock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CacheLockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CacheLockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CacheLockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CacheLock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CacheLockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cachelock.FieldExpiredAt) {
		fields = append(fields, cachelock.FieldExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CacheLockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CacheLockMutation) ClearField(name string) error {
	switch name {
	case cachelock.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown CacheLock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CacheLockMutation) ResetField(name string) error {
	switch name {
	case cachelock.FieldKey:
		m.ResetKey()
		return nil
	case cachelock.FieldOwner:
		m.ResetOwner()
		return nil
	case cachelock.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown CacheLock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CacheLockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CacheLockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CacheLockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CacheLockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CacheLockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CacheLockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CacheLockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CacheLock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CacheLockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CacheLock edge %s", name)
}

// ChangelogMutation represents an operation that mutates the Changelog nodes in the graph.
type ChangelogMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	version                  *int
	addversion               *int
	username                 *string
	_config                  *string
	git_branch               *string
	git_commit               *string
	docker_image             *[]string
	appenddocker_image       []string
	env_values               *[]*types.KeyValue
	appendenv_values         []*types.KeyValue
	extra_values             *[]*websocket.ExtraValue
	appendextra_values       []*websocket.ExtraValue
	final_extra_values       *[]*websocket.ExtraValue
	appendfinal_extra_values []*websocket.ExtraValue
	git_commit_web_url       *string
	git_commit_title         *string
	git_commit_author        *string
	git_commit_date          *time.Time
	config_changed           *bool
	clearedFields            map[string]struct{}
	project                  *int
	clearedproject           bool
	done                     bool
	oldValue                 func(context.Context) (*Changelog, error)
	predicates               []predicate.Changelog
}

var _ ent.Mutation = (*ChangelogMutation)(nil)

// changelogOption allows management of the mutation configuration using functional options.
type changelogOption func(*ChangelogMutation)

// newChangelogMutation creates new mutation for the Changelog entity.
func newChangelogMutation(c config, op Op, opts ...changelogOption) *ChangelogMutation {
	m := &ChangelogMutation{
		config:        c,
		op:            op,
		typ:           TypeChangelog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChangelogID sets the ID field of the mutation.
func withChangelogID(id int) changelogOption {
	return func(m *ChangelogMutation) {
		var (
			err   error
			once  sync.Once
			value *Changelog
		)
		m.oldValue = func(ctx context.Context) (*Changelog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Changelog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChangelog sets the old Changelog of the mutation.
func withChangelog(node *Changelog) changelogOption {
	return func(m *ChangelogMutation) {
		m.oldValue = func(context.Context) (*Changelog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChangelogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChangelogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChangelogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChangelogMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Changelog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChangelogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChangelogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChangelogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChangelogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChangelogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChangelogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChangelogMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChangelogMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChangelogMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[changelog.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChangelogMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[changelog.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChangelogMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, changelog.FieldDeletedAt)
}

// SetVersion sets the "version" field.
func (m *ChangelogMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ChangelogMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ChangelogMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ChangelogMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ChangelogMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetUsername sets the "username" field.
func (m *ChangelogMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ChangelogMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *ChangelogMutation) ResetUsername() {
	m.username = nil
}

// SetConfig sets the "config" field.
func (m *ChangelogMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *ChangelogMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ChangelogMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[changelog.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ChangelogMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[changelog.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ChangelogMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, changelog.FieldConfig)
}

// SetGitBranch sets the "git_branch" field.
func (m *ChangelogMutation) SetGitBranch(s string) {
	m.git_branch = &s
}

// GitBranch returns the value of the "git_branch" field in the mutation.
func (m *ChangelogMutation) GitBranch() (r string, exists bool) {
	v := m.git_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldGitBranch returns the old "git_branch" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitBranch: %w", err)
	}
	return oldValue.GitBranch, nil
}

// ClearGitBranch clears the value of the "git_branch" field.
func (m *ChangelogMutation) ClearGitBranch() {
	m.git_branch = nil
	m.clearedFields[changelog.FieldGitBranch] = struct{}{}
}

// GitBranchCleared returns if the "git_branch" field was cleared in this mutation.
func (m *ChangelogMutation) GitBranchCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitBranch]
	return ok
}

// ResetGitBranch resets all changes to the "git_branch" field.
func (m *ChangelogMutation) ResetGitBranch() {
	m.git_branch = nil
	delete(m.clearedFields, changelog.FieldGitBranch)
}

// SetGitCommit sets the "git_commit" field.
func (m *ChangelogMutation) SetGitCommit(s string) {
	m.git_commit = &s
}

// GitCommit returns the value of the "git_commit" field in the mutation.
func (m *ChangelogMutation) GitCommit() (r string, exists bool) {
	v := m.git_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommit returns the old "git_commit" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommit: %w", err)
	}
	return oldValue.GitCommit, nil
}

// ClearGitCommit clears the value of the "git_commit" field.
func (m *ChangelogMutation) ClearGitCommit() {
	m.git_commit = nil
	m.clearedFields[changelog.FieldGitCommit] = struct{}{}
}

// GitCommitCleared returns if the "git_commit" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommit]
	return ok
}

// ResetGitCommit resets all changes to the "git_commit" field.
func (m *ChangelogMutation) ResetGitCommit() {
	m.git_commit = nil
	delete(m.clearedFields, changelog.FieldGitCommit)
}

// SetDockerImage sets the "docker_image" field.
func (m *ChangelogMutation) SetDockerImage(s []string) {
	m.docker_image = &s
	m.appenddocker_image = nil
}

// DockerImage returns the value of the "docker_image" field in the mutation.
func (m *ChangelogMutation) DockerImage() (r []string, exists bool) {
	v := m.docker_image
	if v == nil {
		return
	}
	return *v, true
}

// OldDockerImage returns the old "docker_image" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldDockerImage(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDockerImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDockerImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDockerImage: %w", err)
	}
	return oldValue.DockerImage, nil
}

// AppendDockerImage adds s to the "docker_image" field.
func (m *ChangelogMutation) AppendDockerImage(s []string) {
	m.appenddocker_image = append(m.appenddocker_image, s...)
}

// AppendedDockerImage returns the list of values that were appended to the "docker_image" field in this mutation.
func (m *ChangelogMutation) AppendedDockerImage() ([]string, bool) {
	if len(m.appenddocker_image) == 0 {
		return nil, false
	}
	return m.appenddocker_image, true
}

// ClearDockerImage clears the value of the "docker_image" field.
func (m *ChangelogMutation) ClearDockerImage() {
	m.docker_image = nil
	m.appenddocker_image = nil
	m.clearedFields[changelog.FieldDockerImage] = struct{}{}
}

// DockerImageCleared returns if the "docker_image" field was cleared in this mutation.
func (m *ChangelogMutation) DockerImageCleared() bool {
	_, ok := m.clearedFields[changelog.FieldDockerImage]
	return ok
}

// ResetDockerImage resets all changes to the "docker_image" field.
func (m *ChangelogMutation) ResetDockerImage() {
	m.docker_image = nil
	m.appenddocker_image = nil
	delete(m.clearedFields, changelog.FieldDockerImage)
}

// SetEnvValues sets the "env_values" field.
func (m *ChangelogMutation) SetEnvValues(tv []*types.KeyValue) {
	m.env_values = &tv
	m.appendenv_values = nil
}

// EnvValues returns the value of the "env_values" field in the mutation.
func (m *ChangelogMutation) EnvValues() (r []*types.KeyValue, exists bool) {
	v := m.env_values
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvValues returns the old "env_values" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldEnvValues(ctx context.Context) (v []*types.KeyValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvValues: %w", err)
	}
	return oldValue.EnvValues, nil
}

// AppendEnvValues adds tv to the "env_values" field.
func (m *ChangelogMutation) AppendEnvValues(tv []*types.KeyValue) {
	m.appendenv_values = append(m.appendenv_values, tv...)
}

// AppendedEnvValues returns the list of values that were appended to the "env_values" field in this mutation.
func (m *ChangelogMutation) AppendedEnvValues() ([]*types.KeyValue, bool) {
	if len(m.appendenv_values) == 0 {
		return nil, false
	}
	return m.appendenv_values, true
}

// ClearEnvValues clears the value of the "env_values" field.
func (m *ChangelogMutation) ClearEnvValues() {
	m.env_values = nil
	m.appendenv_values = nil
	m.clearedFields[changelog.FieldEnvValues] = struct{}{}
}

// EnvValuesCleared returns if the "env_values" field was cleared in this mutation.
func (m *ChangelogMutation) EnvValuesCleared() bool {
	_, ok := m.clearedFields[changelog.FieldEnvValues]
	return ok
}

// ResetEnvValues resets all changes to the "env_values" field.
func (m *ChangelogMutation) ResetEnvValues() {
	m.env_values = nil
	m.appendenv_values = nil
	delete(m.clearedFields, changelog.FieldEnvValues)
}

// SetExtraValues sets the "extra_values" field.
func (m *ChangelogMutation) SetExtraValues(wv []*websocket.ExtraValue) {
	m.extra_values = &wv
	m.appendextra_values = nil
}

// ExtraValues returns the value of the "extra_values" field in the mutation.
func (m *ChangelogMutation) ExtraValues() (r []*websocket.ExtraValue, exists bool) {
	v := m.extra_values
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraValues returns the old "extra_values" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldExtraValues(ctx context.Context) (v []*websocket.ExtraValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraValues: %w", err)
	}
	return oldValue.ExtraValues, nil
}

// AppendExtraValues adds wv to the "extra_values" field.
func (m *ChangelogMutation) AppendExtraValues(wv []*websocket.ExtraValue) {
	m.appendextra_values = append(m.appendextra_values, wv...)
}

// AppendedExtraValues returns the list of values that were appended to the "extra_values" field in this mutation.
func (m *ChangelogMutation) AppendedExtraValues() ([]*websocket.ExtraValue, bool) {
	if len(m.appendextra_values) == 0 {
		return nil, false
	}
	return m.appendextra_values, true
}

// ClearExtraValues clears the value of the "extra_values" field.
func (m *ChangelogMutation) ClearExtraValues() {
	m.extra_values = nil
	m.appendextra_values = nil
	m.clearedFields[changelog.FieldExtraValues] = struct{}{}
}

// ExtraValuesCleared returns if the "extra_values" field was cleared in this mutation.
func (m *ChangelogMutation) ExtraValuesCleared() bool {
	_, ok := m.clearedFields[changelog.FieldExtraValues]
	return ok
}

// ResetExtraValues resets all changes to the "extra_values" field.
func (m *ChangelogMutation) ResetExtraValues() {
	m.extra_values = nil
	m.appendextra_values = nil
	delete(m.clearedFields, changelog.FieldExtraValues)
}

// SetFinalExtraValues sets the "final_extra_values" field.
func (m *ChangelogMutation) SetFinalExtraValues(wv []*websocket.ExtraValue) {
	m.final_extra_values = &wv
	m.appendfinal_extra_values = nil
}

// FinalExtraValues returns the value of the "final_extra_values" field in the mutation.
func (m *ChangelogMutation) FinalExtraValues() (r []*websocket.ExtraValue, exists bool) {
	v := m.final_extra_values
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalExtraValues returns the old "final_extra_values" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldFinalExtraValues(ctx context.Context) (v []*websocket.ExtraValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalExtraValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalExtraValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalExtraValues: %w", err)
	}
	return oldValue.FinalExtraValues, nil
}

// AppendFinalExtraValues adds wv to the "final_extra_values" field.
func (m *ChangelogMutation) AppendFinalExtraValues(wv []*websocket.ExtraValue) {
	m.appendfinal_extra_values = append(m.appendfinal_extra_values, wv...)
}

// AppendedFinalExtraValues returns the list of values that were appended to the "final_extra_values" field in this mutation.
func (m *ChangelogMutation) AppendedFinalExtraValues() ([]*websocket.ExtraValue, bool) {
	if len(m.appendfinal_extra_values) == 0 {
		return nil, false
	}
	return m.appendfinal_extra_values, true
}

// ClearFinalExtraValues clears the value of the "final_extra_values" field.
func (m *ChangelogMutation) ClearFinalExtraValues() {
	m.final_extra_values = nil
	m.appendfinal_extra_values = nil
	m.clearedFields[changelog.FieldFinalExtraValues] = struct{}{}
}

// FinalExtraValuesCleared returns if the "final_extra_values" field was cleared in this mutation.
func (m *ChangelogMutation) FinalExtraValuesCleared() bool {
	_, ok := m.clearedFields[changelog.FieldFinalExtraValues]
	return ok
}

// ResetFinalExtraValues resets all changes to the "final_extra_values" field.
func (m *ChangelogMutation) ResetFinalExtraValues() {
	m.final_extra_values = nil
	m.appendfinal_extra_values = nil
	delete(m.clearedFields, changelog.FieldFinalExtraValues)
}

// SetGitCommitWebURL sets the "git_commit_web_url" field.
func (m *ChangelogMutation) SetGitCommitWebURL(s string) {
	m.git_commit_web_url = &s
}

// GitCommitWebURL returns the value of the "git_commit_web_url" field in the mutation.
func (m *ChangelogMutation) GitCommitWebURL() (r string, exists bool) {
	v := m.git_commit_web_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitWebURL returns the old "git_commit_web_url" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommitWebURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitWebURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitWebURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitWebURL: %w", err)
	}
	return oldValue.GitCommitWebURL, nil
}

// ClearGitCommitWebURL clears the value of the "git_commit_web_url" field.
func (m *ChangelogMutation) ClearGitCommitWebURL() {
	m.git_commit_web_url = nil
	m.clearedFields[changelog.FieldGitCommitWebURL] = struct{}{}
}

// GitCommitWebURLCleared returns if the "git_commit_web_url" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitWebURLCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommitWebURL]
	return ok
}

// ResetGitCommitWebURL resets all changes to the "git_commit_web_url" field.
func (m *ChangelogMutation) ResetGitCommitWebURL() {
	m.git_commit_web_url = nil
	delete(m.clearedFields, changelog.FieldGitCommitWebURL)
}

// SetGitCommitTitle sets the "git_commit_title" field.
func (m *ChangelogMutation) SetGitCommitTitle(s string) {
	m.git_commit_title = &s
}

// GitCommitTitle returns the value of the "git_commit_title" field in the mutation.
func (m *ChangelogMutation) GitCommitTitle() (r string, exists bool) {
	v := m.git_commit_title
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitTitle returns the old "git_commit_title" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommitTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitTitle: %w", err)
	}
	return oldValue.GitCommitTitle, nil
}

// ClearGitCommitTitle clears the value of the "git_commit_title" field.
func (m *ChangelogMutation) ClearGitCommitTitle() {
	m.git_commit_title = nil
	m.clearedFields[changelog.FieldGitCommitTitle] = struct{}{}
}

// GitCommitTitleCleared returns if the "git_commit_title" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitTitleCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommitTitle]
	return ok
}

// ResetGitCommitTitle resets all changes to the "git_commit_title" field.
func (m *ChangelogMutation) ResetGitCommitTitle() {
	m.git_commit_title = nil
	delete(m.clearedFields, changelog.FieldGitCommitTitle)
}

// SetGitCommitAuthor sets the "git_commit_author" field.
func (m *ChangelogMutation) SetGitCommitAuthor(s string) {
	m.git_commit_author = &s
}

// GitCommitAuthor returns the value of the "git_commit_author" field in the mutation.
func (m *ChangelogMutation) GitCommitAuthor() (r string, exists bool) {
	v := m.git_commit_author
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitAuthor returns the old "git_commit_author" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommitAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitAuthor: %w", err)
	}
	return oldValue.GitCommitAuthor, nil
}

// ClearGitCommitAuthor clears the value of the "git_commit_author" field.
func (m *ChangelogMutation) ClearGitCommitAuthor() {
	m.git_commit_author = nil
	m.clearedFields[changelog.FieldGitCommitAuthor] = struct{}{}
}

// GitCommitAuthorCleared returns if the "git_commit_author" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitAuthorCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommitAuthor]
	return ok
}

// ResetGitCommitAuthor resets all changes to the "git_commit_author" field.
func (m *ChangelogMutation) ResetGitCommitAuthor() {
	m.git_commit_author = nil
	delete(m.clearedFields, changelog.FieldGitCommitAuthor)
}

// SetGitCommitDate sets the "git_commit_date" field.
func (m *ChangelogMutation) SetGitCommitDate(t time.Time) {
	m.git_commit_date = &t
}

// GitCommitDate returns the value of the "git_commit_date" field in the mutation.
func (m *ChangelogMutation) GitCommitDate() (r time.Time, exists bool) {
	v := m.git_commit_date
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitDate returns the old "git_commit_date" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldGitCommitDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitDate: %w", err)
	}
	return oldValue.GitCommitDate, nil
}

// ClearGitCommitDate clears the value of the "git_commit_date" field.
func (m *ChangelogMutation) ClearGitCommitDate() {
	m.git_commit_date = nil
	m.clearedFields[changelog.FieldGitCommitDate] = struct{}{}
}

// GitCommitDateCleared returns if the "git_commit_date" field was cleared in this mutation.
func (m *ChangelogMutation) GitCommitDateCleared() bool {
	_, ok := m.clearedFields[changelog.FieldGitCommitDate]
	return ok
}

// ResetGitCommitDate resets all changes to the "git_commit_date" field.
func (m *ChangelogMutation) ResetGitCommitDate() {
	m.git_commit_date = nil
	delete(m.clearedFields, changelog.FieldGitCommitDate)
}

// SetConfigChanged sets the "config_changed" field.
func (m *ChangelogMutation) SetConfigChanged(b bool) {
	m.config_changed = &b
}

// ConfigChanged returns the value of the "config_changed" field in the mutation.
func (m *ChangelogMutation) ConfigChanged() (r bool, exists bool) {
	v := m.config_changed
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigChanged returns the old "config_changed" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldConfigChanged(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigChanged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigChanged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigChanged: %w", err)
	}
	return oldValue.ConfigChanged, nil
}

// ResetConfigChanged resets all changes to the "config_changed" field.
func (m *ChangelogMutation) ResetConfigChanged() {
	m.config_changed = nil
}

// SetProjectID sets the "project_id" field.
func (m *ChangelogMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ChangelogMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Changelog entity.
// If the Changelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangelogMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ClearProjectID clears the value of the "project_id" field.
func (m *ChangelogMutation) ClearProjectID() {
	m.project = nil
	m.clearedFields[changelog.FieldProjectID] = struct{}{}
}

// ProjectIDCleared returns if the "project_id" field was cleared in this mutation.
func (m *ChangelogMutation) ProjectIDCleared() bool {
	_, ok := m.clearedFields[changelog.FieldProjectID]
	return ok
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ChangelogMutation) ResetProjectID() {
	m.project = nil
	delete(m.clearedFields, changelog.FieldProjectID)
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ChangelogMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[changelog.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ChangelogMutation) ProjectCleared() bool {
	return m.ProjectIDCleared() || m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ChangelogMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ChangelogMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the ChangelogMutation builder.
func (m *ChangelogMutation) Where(ps ...predicate.Changelog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChangelogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChangelogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Changelog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChangelogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChangelogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Changelog).
func (m *ChangelogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChangelogMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, changelog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, changelog.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, changelog.FieldDeletedAt)
	}
	if m.version != nil {
		fields = append(fields, changelog.FieldVersion)
	}
	if m.username != nil {
		fields = append(fields, changelog.FieldUsername)
	}
	if m._config != nil {
		fields = append(fields, changelog.FieldConfig)
	}
	if m.git_branch != nil {
		fields = append(fields, changelog.FieldGitBranch)
	}
	if m.git_commit != nil {
		fields = append(fields, changelog.FieldGitCommit)
	}
	if m.docker_image != nil {
		fields = append(fields, changelog.FieldDockerImage)
	}
	if m.env_values != nil {
		fields = append(fields, changelog.FieldEnvValues)
	}
	if m.extra_values != nil {
		fields = append(fields, changelog.FieldExtraValues)
	}
	if m.final_extra_values != nil {
		fields = append(fields, changelog.FieldFinalExtraValues)
	}
	if m.git_commit_web_url != nil {
		fields = append(fields, changelog.FieldGitCommitWebURL)
	}
	if m.git_commit_title != nil {
		fields = append(fields, changelog.FieldGitCommitTitle)
	}
	if m.git_commit_author != nil {
		fields = append(fields, changelog.FieldGitCommitAuthor)
	}
	if m.git_commit_date != nil {
		fields = append(fields, changelog.FieldGitCommitDate)
	}
	if m.config_changed != nil {
		fields = append(fields, changelog.FieldConfigChanged)
	}
	if m.project != nil {
		fields = append(fields, changelog.FieldProjectID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChangelogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case changelog.FieldCreatedAt:
		return m.CreatedAt()
	case changelog.FieldUpdatedAt:
		return m.UpdatedAt()
	case changelog.FieldDeletedAt:
		return m.DeletedAt()
	case changelog.FieldVersion:
		return m.Version()
	case changelog.FieldUsername:
		return m.Username()
	case changelog.FieldConfig:
		return m.Config()
	case changelog.FieldGitBranch:
		return m.GitBranch()
	case changelog.FieldGitCommit:
		return m.GitCommit()
	case changelog.FieldDockerImage:
		return m.DockerImage()
	case changelog.FieldEnvValues:
		return m.EnvValues()
	case changelog.FieldExtraValues:
		return m.ExtraValues()
	case changelog.FieldFinalExtraValues:
		return m.FinalExtraValues()
	case changelog.FieldGitCommitWebURL:
		return m.GitCommitWebURL()
	case changelog.FieldGitCommitTitle:
		return m.GitCommitTitle()
	case changelog.FieldGitCommitAuthor:
		return m.GitCommitAuthor()
	case changelog.FieldGitCommitDate:
		return m.GitCommitDate()
	case changelog.FieldConfigChanged:
		return m.ConfigChanged()
	case changelog.FieldProjectID:
		return m.ProjectID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChangelogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case changelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case changelog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case changelog.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case changelog.FieldVersion:
		return m.OldVersion(ctx)
	case changelog.FieldUsername:
		return m.OldUsername(ctx)
	case changelog.FieldConfig:
		return m.OldConfig(ctx)
	case changelog.FieldGitBranch:
		return m.OldGitBranch(ctx)
	case changelog.FieldGitCommit:
		return m.OldGitCommit(ctx)
	case changelog.FieldDockerImage:
		return m.OldDockerImage(ctx)
	case changelog.FieldEnvValues:
		return m.OldEnvValues(ctx)
	case changelog.FieldExtraValues:
		return m.OldExtraValues(ctx)
	case changelog.FieldFinalExtraValues:
		return m.OldFinalExtraValues(ctx)
	case changelog.FieldGitCommitWebURL:
		return m.OldGitCommitWebURL(ctx)
	case changelog.FieldGitCommitTitle:
		return m.OldGitCommitTitle(ctx)
	case changelog.FieldGitCommitAuthor:
		return m.OldGitCommitAuthor(ctx)
	case changelog.FieldGitCommitDate:
		return m.OldGitCommitDate(ctx)
	case changelog.FieldConfigChanged:
		return m.OldConfigChanged(ctx)
	case changelog.FieldProjectID:
		return m.OldProjectID(ctx)
	}
	return nil, fmt.Errorf("unknown Changelog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangelogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case changelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case changelog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case changelog.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case changelog.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case changelog.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case changelog.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case changelog.FieldGitBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitBranch(v)
		return nil
	case changelog.FieldGitCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommit(v)
		return nil
	case changelog.FieldDockerImage:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDockerImage(v)
		return nil
	case changelog.FieldEnvValues:
		v, ok := value.([]*types.KeyValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvValues(v)
		return nil
	case changelog.FieldExtraValues:
		v, ok := value.([]*websocket.ExtraValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraValues(v)
		return nil
	case changelog.FieldFinalExtraValues:
		v, ok := value.([]*websocket.ExtraValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalExtraValues(v)
		return nil
	case changelog.FieldGitCommitWebURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitWebURL(v)
		return nil
	case changelog.FieldGitCommitTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitTitle(v)
		return nil
	case changelog.FieldGitCommitAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitAuthor(v)
		return nil
	case changelog.FieldGitCommitDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitDate(v)
		return nil
	case changelog.FieldConfigChanged:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigChanged(v)
		return nil
	case changelog.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Changelog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChangelogMutation) AddedFields() []string {
	var fields []string
	if m.addversion != nil {
		fields = append(fields, changelog.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChangelogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case changelog.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangelogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case changelog.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Changelog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChangelogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(changelog.FieldDeletedAt) {
		fields = append(fields, changelog.FieldDeletedAt)
	}
	if m.FieldCleared(changelog.FieldConfig) {
		fields = append(fields, changelog.FieldConfig)
	}
	if m.FieldCleared(changelog.FieldGitBranch) {
		fields = append(fields, changelog.FieldGitBranch)
	}
	if m.FieldCleared(changelog.FieldGitCommit) {
		fields = append(fields, changelog.FieldGitCommit)
	}
	if m.FieldCleared(changelog.FieldDockerImage) {
		fields = append(fields, changelog.FieldDockerImage)
	}
	if m.FieldCleared(changelog.FieldEnvValues) {
		fields = append(fields, changelog.FieldEnvValues)
	}
	if m.FieldCleared(changelog.FieldExtraValues) {
		fields = append(fields, changelog.FieldExtraValues)
	}
	if m.FieldCleared(changelog.FieldFinalExtraValues) {
		fields = append(fields, changelog.FieldFinalExtraValues)
	}
	if m.FieldCleared(changelog.FieldGitCommitWebURL) {
		fields = append(fields, changelog.FieldGitCommitWebURL)
	}
	if m.FieldCleared(changelog.FieldGitCommitTitle) {
		fields = append(fields, changelog.FieldGitCommitTitle)
	}
	if m.FieldCleared(changelog.FieldGitCommitAuthor) {
		fields = append(fields, changelog.FieldGitCommitAuthor)
	}
	if m.FieldCleared(changelog.FieldGitCommitDate) {
		fields = append(fields, changelog.FieldGitCommitDate)
	}
	if m.FieldCleared(changelog.FieldProjectID) {
		fields = append(fields, changelog.FieldProjectID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChangelogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChangelogMutation) ClearField(name string) error {
	switch name {
	case changelog.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case changelog.FieldConfig:
		m.ClearConfig()
		return nil
	case changelog.FieldGitBranch:
		m.ClearGitBranch()
		return nil
	case changelog.FieldGitCommit:
		m.ClearGitCommit()
		return nil
	case changelog.FieldDockerImage:
		m.ClearDockerImage()
		return nil
	case changelog.FieldEnvValues:
		m.ClearEnvValues()
		return nil
	case changelog.FieldExtraValues:
		m.ClearExtraValues()
		return nil
	case changelog.FieldFinalExtraValues:
		m.ClearFinalExtraValues()
		return nil
	case changelog.FieldGitCommitWebURL:
		m.ClearGitCommitWebURL()
		return nil
	case changelog.FieldGitCommitTitle:
		m.ClearGitCommitTitle()
		return nil
	case changelog.FieldGitCommitAuthor:
		m.ClearGitCommitAuthor()
		return nil
	case changelog.FieldGitCommitDate:
		m.ClearGitCommitDate()
		return nil
	case changelog.FieldProjectID:
		m.ClearProjectID()
		return nil
	}
	return fmt.Errorf("unknown Changelog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChangelogMutation) ResetField(name string) error {
	switch name {
	case changelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case changelog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case changelog.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case changelog.FieldVersion:
		m.ResetVersion()
		return nil
	case changelog.FieldUsername:
		m.ResetUsername()
		return nil
	case changelog.FieldConfig:
		m.ResetConfig()
		return nil
	case changelog.FieldGitBranch:
		m.ResetGitBranch()
		return nil
	case changelog.FieldGitCommit:
		m.ResetGitCommit()
		return nil
	case changelog.FieldDockerImage:
		m.ResetDockerImage()
		return nil
	case changelog.FieldEnvValues:
		m.ResetEnvValues()
		return nil
	case changelog.FieldExtraValues:
		m.ResetExtraValues()
		return nil
	case changelog.FieldFinalExtraValues:
		m.ResetFinalExtraValues()
		return nil
	case changelog.FieldGitCommitWebURL:
		m.ResetGitCommitWebURL()
		return nil
	case changelog.FieldGitCommitTitle:
		m.ResetGitCommitTitle()
		return nil
	case changelog.FieldGitCommitAuthor:
		m.ResetGitCommitAuthor()
		return nil
	case changelog.FieldGitCommitDate:
		m.ResetGitCommitDate()
		return nil
	case changelog.FieldConfigChanged:
		m.ResetConfigChanged()
		return nil
	case changelog.FieldProjectID:
		m.ResetProjectID()
		return nil
	}
	return fmt.Errorf("unknown Changelog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChangelogMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project != nil {
		edges = append(edges, changelog.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChangelogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case changelog.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChangelogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChangelogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChangelogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject {
		edges = append(edges, changelog.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChangelogMutation) EdgeCleared(name string) bool {
	switch name {
	case changelog.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChangelogMutation) ClearEdge(name string) error {
	switch name {
	case changelog.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown Changelog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChangelogMutation) ResetEdge(name string) error {
	switch name {
	case changelog.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown Changelog edge %s", name)
}

// DBCacheMutation represents an operation that mutates the DBCache nodes in the graph.
type DBCacheMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	value         *string
	expired_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DBCache, error)
	predicates    []predicate.DBCache
}

var _ ent.Mutation = (*DBCacheMutation)(nil)

// dbcacheOption allows management of the mutation configuration using functional options.
type dbcacheOption func(*DBCacheMutation)

// newDBCacheMutation creates new mutation for the DBCache entity.
func newDBCacheMutation(c config, op Op, opts ...dbcacheOption) *DBCacheMutation {
	m := &DBCacheMutation{
		config:        c,
		op:            op,
		typ:           TypeDBCache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDBCacheID sets the ID field of the mutation.
func withDBCacheID(id int) dbcacheOption {
	return func(m *DBCacheMutation) {
		var (
			err   error
			once  sync.Once
			value *DBCache
		)
		m.oldValue = func(ctx context.Context) (*DBCache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DBCache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDBCache sets the old DBCache of the mutation.
func withDBCache(node *DBCache) dbcacheOption {
	return func(m *DBCacheMutation) {
		m.oldValue = func(context.Context) (*DBCache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DBCacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DBCacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DBCacheMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DBCacheMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DBCache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *DBCacheMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DBCacheMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the DBCache entity.
// If the DBCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DBCacheMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DBCacheMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *DBCacheMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DBCacheMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the DBCache entity.
// If the DBCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DBCacheMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *DBCacheMutation) ClearValue() {
	m.value = nil
	m.clearedFields[dbcache.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *DBCacheMutation) ValueCleared() bool {
	_, ok := m.clearedFields[dbcache.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *DBCacheMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, dbcache.FieldValue)
}

// SetExpiredAt sets the "expired_at" field.
func (m *DBCacheMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *DBCacheMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the DBCache entity.
// If the DBCache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DBCacheMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *DBCacheMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[dbcache.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *DBCacheMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[dbcache.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *DBCacheMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, dbcache.FieldExpiredAt)
}

// Where appends a list predicates to the DBCacheMutation builder.
func (m *DBCacheMutation) Where(ps ...predicate.DBCache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DBCacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DBCacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DBCache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DBCacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DBCacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DBCache).
func (m *DBCacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DBCacheMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, dbcache.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, dbcache.FieldValue)
	}
	if m.expired_at != nil {
		fields = append(fields, dbcache.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DBCacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dbcache.FieldKey:
		return m.Key()
	case dbcache.FieldValue:
		return m.Value()
	case dbcache.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DBCacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dbcache.FieldKey:
		return m.OldKey(ctx)
	case dbcache.FieldValue:
		return m.OldValue(ctx)
	case dbcache.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown DBCache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DBCacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dbcache.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case dbcache.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dbcache.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown DBCache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DBCacheMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DBCacheMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DBCacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DBCache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DBCacheMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dbcache.FieldValue) {
		fields = append(fields, dbcache.FieldValue)
	}
	if m.FieldCleared(dbcache.FieldExpiredAt) {
		fields = append(fields, dbcache.FieldExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DBCacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DBCacheMutation) ClearField(name string) error {
	switch name {
	case dbcache.FieldValue:
		m.ClearValue()
		return nil
	case dbcache.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown DBCache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DBCacheMutation) ResetField(name string) error {
	switch name {
	case dbcache.FieldKey:
		m.ResetKey()
		return nil
	case dbcache.FieldValue:
		m.ResetValue()
		return nil
	case dbcache.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown DBCache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DBCacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DBCacheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DBCacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DBCacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DBCacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DBCacheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DBCacheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DBCache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DBCacheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DBCache edge %s", name)
}

// EventMutation represents an operation that mutates the Event nodes in the graph.
type EventMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	action        *types.EventActionType
	addaction     *types.EventActionType
	username      *string
	message       *string
	old           *string
	new           *string
	has_diff      *bool
	duration      *string
	clearedFields map[string]struct{}
	file          *int
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*Event, error)
	predicates    []predicate.Event
}

var _ ent.Mutation = (*EventMutation)(nil)

// eventOption allows management of the mutation configuration using functional options.
type eventOption func(*EventMutation)

// newEventMutation creates new mutation for the Event entity.
func newEventMutation(c config, op Op, opts ...eventOption) *EventMutation {
	m := &EventMutation{
		config:        c,
		op:            op,
		typ:           TypeEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventID sets the ID field of the mutation.
func withEventID(id int) eventOption {
	return func(m *EventMutation) {
		var (
			err   error
			once  sync.Once
			value *Event
		)
		m.oldValue = func(ctx context.Context) (*Event, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Event.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvent sets the old Event of the mutation.
func withEvent(node *Event) eventOption {
	return func(m *EventMutation) {
		m.oldValue = func(context.Context) (*Event, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Event.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EventMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EventMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EventMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[event.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EventMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[event.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EventMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, event.FieldDeletedAt)
}

// SetAction sets the "action" field.
func (m *EventMutation) SetAction(tat types.EventActionType) {
	m.action = &tat
	m.addaction = nil
}

// Action returns the value of the "action" field in the mutation.
func (m *EventMutation) Action() (r types.EventActionType, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldAction(ctx context.Context) (v types.EventActionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// AddAction adds tat to the "action" field.
func (m *EventMutation) AddAction(tat types.EventActionType) {
	if m.addaction != nil {
		*m.addaction += tat
	} else {
		m.addaction = &tat
	}
}

// AddedAction returns the value that was added to the "action" field in this mutation.
func (m *EventMutation) AddedAction() (r types.EventActionType, exists bool) {
	v := m.addaction
	if v == nil {
		return
	}
	return *v, true
}

// ResetAction resets all changes to the "action" field.
func (m *EventMutation) ResetAction() {
	m.action = nil
	m.addaction = nil
}

// SetUsername sets the "username" field.
func (m *EventMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *EventMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *EventMutation) ResetUsername() {
	m.username = nil
}

// SetMessage sets the "message" field.
func (m *EventMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *EventMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *EventMutation) ResetMessage() {
	m.message = nil
}

// SetOld sets the "old" field.
func (m *EventMutation) SetOld(s string) {
	m.old = &s
}

// Old returns the value of the "old" field in the mutation.
func (m *EventMutation) Old() (r string, exists bool) {
	v := m.old
	if v == nil {
		return
	}
	return *v, true
}

// OldOld returns the old "old" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldOld(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOld: %w", err)
	}
	return oldValue.Old, nil
}

// ClearOld clears the value of the "old" field.
func (m *EventMutation) ClearOld() {
	m.old = nil
	m.clearedFields[event.FieldOld] = struct{}{}
}

// OldCleared returns if the "old" field was cleared in this mutation.
func (m *EventMutation) OldCleared() bool {
	_, ok := m.clearedFields[event.FieldOld]
	return ok
}

// ResetOld resets all changes to the "old" field.
func (m *EventMutation) ResetOld() {
	m.old = nil
	delete(m.clearedFields, event.FieldOld)
}

// SetNew sets the "new" field.
func (m *EventMutation) SetNew(s string) {
	m.new = &s
}

// New returns the value of the "new" field in the mutation.
func (m *EventMutation) New() (r string, exists bool) {
	v := m.new
	if v == nil {
		return
	}
	return *v, true
}

// OldNew returns the old "new" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldNew(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNew is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNew requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNew: %w", err)
	}
	return oldValue.New, nil
}

// ClearNew clears the value of the "new" field.
func (m *EventMutation) ClearNew() {
	m.new = nil
	m.clearedFields[event.FieldNew] = struct{}{}
}

// NewCleared returns if the "new" field was cleared in this mutation.
func (m *EventMutation) NewCleared() bool {
	_, ok := m.clearedFields[event.FieldNew]
	return ok
}

// ResetNew resets all changes to the "new" field.
func (m *EventMutation) ResetNew() {
	m.new = nil
	delete(m.clearedFields, event.FieldNew)
}

// SetHasDiff sets the "has_diff" field.
func (m *EventMutation) SetHasDiff(b bool) {
	m.has_diff = &b
}

// HasDiff returns the value of the "has_diff" field in the mutation.
func (m *EventMutation) HasDiff() (r bool, exists bool) {
	v := m.has_diff
	if v == nil {
		return
	}
	return *v, true
}

// OldHasDiff returns the old "has_diff" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldHasDiff(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasDiff is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasDiff requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasDiff: %w", err)
	}
	return oldValue.HasDiff, nil
}

// ResetHasDiff resets all changes to the "has_diff" field.
func (m *EventMutation) ResetHasDiff() {
	m.has_diff = nil
}

// SetDuration sets the "duration" field.
func (m *EventMutation) SetDuration(s string) {
	m.duration = &s
}

// Duration returns the value of the "duration" field in the mutation.
func (m *EventMutation) Duration() (r string, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldDuration(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ResetDuration resets all changes to the "duration" field.
func (m *EventMutation) ResetDuration() {
	m.duration = nil
}

// SetFileID sets the "file_id" field.
func (m *EventMutation) SetFileID(i int) {
	m.file = &i
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *EventMutation) FileID() (r int, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the Event entity.
// If the Event object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventMutation) OldFileID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ClearFileID clears the value of the "file_id" field.
func (m *EventMutation) ClearFileID() {
	m.file = nil
	m.clearedFields[event.FieldFileID] = struct{}{}
}

// FileIDCleared returns if the "file_id" field was cleared in this mutation.
func (m *EventMutation) FileIDCleared() bool {
	_, ok := m.clearedFields[event.FieldFileID]
	return ok
}

// ResetFileID resets all changes to the "file_id" field.
func (m *EventMutation) ResetFileID() {
	m.file = nil
	delete(m.clearedFields, event.FieldFileID)
}

// ClearFile clears the "file" edge to the File entity.
func (m *EventMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[event.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *EventMutation) FileCleared() bool {
	return m.FileIDCleared() || m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *EventMutation) FileIDs() (ids []int) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *EventMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the EventMutation builder.
func (m *EventMutation) Where(ps ...predicate.Event) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Event, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Event).
func (m *EventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, event.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, event.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.action != nil {
		fields = append(fields, event.FieldAction)
	}
	if m.username != nil {
		fields = append(fields, event.FieldUsername)
	}
	if m.message != nil {
		fields = append(fields, event.FieldMessage)
	}
	if m.old != nil {
		fields = append(fields, event.FieldOld)
	}
	if m.new != nil {
		fields = append(fields, event.FieldNew)
	}
	if m.has_diff != nil {
		fields = append(fields, event.FieldHasDiff)
	}
	if m.duration != nil {
		fields = append(fields, event.FieldDuration)
	}
	if m.file != nil {
		fields = append(fields, event.FieldFileID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case event.FieldCreatedAt:
		return m.CreatedAt()
	case event.FieldUpdatedAt:
		return m.UpdatedAt()
	case event.FieldDeletedAt:
		return m.DeletedAt()
	case event.FieldAction:
		return m.Action()
	case event.FieldUsername:
		return m.Username()
	case event.FieldMessage:
		return m.Message()
	case event.FieldOld:
		return m.Old()
	case event.FieldNew:
		return m.New()
	case event.FieldHasDiff:
		return m.HasDiff()
	case event.FieldDuration:
		return m.Duration()
	case event.FieldFileID:
		return m.FileID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case event.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case event.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case event.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case event.FieldAction:
		return m.OldAction(ctx)
	case event.FieldUsername:
		return m.OldUsername(ctx)
	case event.FieldMessage:
		return m.OldMessage(ctx)
	case event.FieldOld:
		return m.OldOld(ctx)
	case event.FieldNew:
		return m.OldNew(ctx)
	case event.FieldHasDiff:
		return m.OldHasDiff(ctx)
	case event.FieldDuration:
		return m.OldDuration(ctx)
	case event.FieldFileID:
		return m.OldFileID(ctx)
	}
	return nil, fmt.Errorf("unknown Event field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case event.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case event.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case event.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case event.FieldAction:
		v, ok := value.(types.EventActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case event.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case event.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case event.FieldOld:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOld(v)
		return nil
	case event.FieldNew:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNew(v)
		return nil
	case event.FieldHasDiff:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasDiff(v)
		return nil
	case event.FieldDuration:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case event.FieldFileID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventMutation) AddedFields() []string {
	var fields []string
	if m.addaction != nil {
		fields = append(fields, event.FieldAction)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case event.FieldAction:
		return m.AddedAction()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventMutation) AddField(name string, value ent.Value) error {
	switch name {
	case event.FieldAction:
		v, ok := value.(types.EventActionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAction(v)
		return nil
	}
	return fmt.Errorf("unknown Event numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(event.FieldDeletedAt) {
		fields = append(fields, event.FieldDeletedAt)
	}
	if m.FieldCleared(event.FieldOld) {
		fields = append(fields, event.FieldOld)
	}
	if m.FieldCleared(event.FieldNew) {
		fields = append(fields, event.FieldNew)
	}
	if m.FieldCleared(event.FieldFileID) {
		fields = append(fields, event.FieldFileID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventMutation) ClearField(name string) error {
	switch name {
	case event.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case event.FieldOld:
		m.ClearOld()
		return nil
	case event.FieldNew:
		m.ClearNew()
		return nil
	case event.FieldFileID:
		m.ClearFileID()
		return nil
	}
	return fmt.Errorf("unknown Event nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventMutation) ResetField(name string) error {
	switch name {
	case event.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case event.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case event.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case event.FieldAction:
		m.ResetAction()
		return nil
	case event.FieldUsername:
		m.ResetUsername()
		return nil
	case event.FieldMessage:
		m.ResetMessage()
		return nil
	case event.FieldOld:
		m.ResetOld()
		return nil
	case event.FieldNew:
		m.ResetNew()
		return nil
	case event.FieldHasDiff:
		m.ResetHasDiff()
		return nil
	case event.FieldDuration:
		m.ResetDuration()
		return nil
	case event.FieldFileID:
		m.ResetFileID()
		return nil
	}
	return fmt.Errorf("unknown Event field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.file != nil {
		edges = append(edges, event.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case event.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedfile {
		edges = append(edges, event.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventMutation) EdgeCleared(name string) bool {
	switch name {
	case event.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventMutation) ClearEdge(name string) error {
	switch name {
	case event.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown Event unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventMutation) ResetEdge(name string) error {
	switch name {
	case event.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown Event edge %s", name)
}

// FavoriteMutation represents an operation that mutates the Favorite nodes in the graph.
type FavoriteMutation struct {
	config
	op               Op
	typ              string
	id               *int
	email            *string
	clearedFields    map[string]struct{}
	namespace        *int
	clearednamespace bool
	done             bool
	oldValue         func(context.Context) (*Favorite, error)
	predicates       []predicate.Favorite
}

var _ ent.Mutation = (*FavoriteMutation)(nil)

// favoriteOption allows management of the mutation configuration using functional options.
type favoriteOption func(*FavoriteMutation)

// newFavoriteMutation creates new mutation for the Favorite entity.
func newFavoriteMutation(c config, op Op, opts ...favoriteOption) *FavoriteMutation {
	m := &FavoriteMutation{
		config:        c,
		op:            op,
		typ:           TypeFavorite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFavoriteID sets the ID field of the mutation.
func withFavoriteID(id int) favoriteOption {
	return func(m *FavoriteMutation) {
		var (
			err   error
			once  sync.Once
			value *Favorite
		)
		m.oldValue = func(ctx context.Context) (*Favorite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Favorite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFavorite sets the old Favorite of the mutation.
func withFavorite(node *Favorite) favoriteOption {
	return func(m *FavoriteMutation) {
		m.oldValue = func(context.Context) (*Favorite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FavoriteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FavoriteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FavoriteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FavoriteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Favorite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *FavoriteMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *FavoriteMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Favorite entity.
// If the Favorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *FavoriteMutation) ResetEmail() {
	m.email = nil
}

// SetNamespaceID sets the "namespace_id" field.
func (m *FavoriteMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *FavoriteMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the Favorite entity.
// If the Favorite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FavoriteMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ClearNamespaceID clears the value of the "namespace_id" field.
func (m *FavoriteMutation) ClearNamespaceID() {
	m.namespace = nil
	m.clearedFields[favorite.FieldNamespaceID] = struct{}{}
}

// NamespaceIDCleared returns if the "namespace_id" field was cleared in this mutation.
func (m *FavoriteMutation) NamespaceIDCleared() bool {
	_, ok := m.clearedFields[favorite.FieldNamespaceID]
	return ok
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *FavoriteMutation) ResetNamespaceID() {
	m.namespace = nil
	delete(m.clearedFields, favorite.FieldNamespaceID)
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *FavoriteMutation) ClearNamespace() {
	m.clearednamespace = true
	m.clearedFields[favorite.FieldNamespaceID] = struct{}{}
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *FavoriteMutation) NamespaceCleared() bool {
	return m.NamespaceIDCleared() || m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *FavoriteMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *FavoriteMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the FavoriteMutation builder.
func (m *FavoriteMutation) Where(ps ...predicate.Favorite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FavoriteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FavoriteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Favorite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FavoriteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FavoriteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Favorite).
func (m *FavoriteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FavoriteMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.email != nil {
		fields = append(fields, favorite.FieldEmail)
	}
	if m.namespace != nil {
		fields = append(fields, favorite.FieldNamespaceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FavoriteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case favorite.FieldEmail:
		return m.Email()
	case favorite.FieldNamespaceID:
		return m.NamespaceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FavoriteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case favorite.FieldEmail:
		return m.OldEmail(ctx)
	case favorite.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	}
	return nil, fmt.Errorf("unknown Favorite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavoriteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case favorite.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case favorite.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	}
	return fmt.Errorf("unknown Favorite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FavoriteMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FavoriteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FavoriteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Favorite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FavoriteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(favorite.FieldNamespaceID) {
		fields = append(fields, favorite.FieldNamespaceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FavoriteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FavoriteMutation) ClearField(name string) error {
	switch name {
	case favorite.FieldNamespaceID:
		m.ClearNamespaceID()
		return nil
	}
	return fmt.Errorf("unknown Favorite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FavoriteMutation) ResetField(name string) error {
	switch name {
	case favorite.FieldEmail:
		m.ResetEmail()
		return nil
	case favorite.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	}
	return fmt.Errorf("unknown Favorite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FavoriteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace != nil {
		edges = append(edges, favorite.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FavoriteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case favorite.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FavoriteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FavoriteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FavoriteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace {
		edges = append(edges, favorite.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FavoriteMutation) EdgeCleared(name string) bool {
	switch name {
	case favorite.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FavoriteMutation) ClearEdge(name string) error {
	switch name {
	case favorite.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Favorite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FavoriteMutation) ResetEdge(name string) error {
	switch name {
	case favorite.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown Favorite edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op             Op
	typ            string
	id             *int
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	upload_type    *schematype.UploadType
	_path          *string
	size           *uint64
	addsize        *int64
	username       *string
	namespace      *string
	pod            *string
	container      *string
	container_path *string
	clearedFields  map[string]struct{}
	events         map[int]struct{}
	removedevents  map[int]struct{}
	clearedevents  bool
	done           bool
	oldValue       func(context.Context) (*File, error)
	predicates     []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetUploadType sets the "upload_type" field.
func (m *FileMutation) SetUploadType(st schematype.UploadType) {
	m.upload_type = &st
}

// UploadType returns the value of the "upload_type" field in the mutation.
func (m *FileMutation) UploadType() (r schematype.UploadType, exists bool) {
	v := m.upload_type
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadType returns the old "upload_type" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUploadType(ctx context.Context) (v schematype.UploadType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadType: %w", err)
	}
	return oldValue.UploadType, nil
}

// ResetUploadType resets all changes to the "upload_type" field.
func (m *FileMutation) ResetUploadType() {
	m.upload_type = nil
}

// SetPath sets the "path" field.
func (m *FileMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *FileMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ResetPath resets all changes to the "path" field.
func (m *FileMutation) ResetPath() {
	m._path = nil
}

// SetSize sets the "size" field.
func (m *FileMutation) SetSize(u uint64) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FileMutation) Size() (r uint64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSize(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *FileMutation) AddSize(u int64) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetUsername sets the "username" field.
func (m *FileMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *FileMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *FileMutation) ResetUsername() {
	m.username = nil
}

// SetNamespace sets the "namespace" field.
func (m *FileMutation) SetNamespace(s string) {
	m.namespace = &s
}

// Namespace returns the value of the "namespace" field in the mutation.
func (m *FileMutation) Namespace() (r string, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespace returns the old "namespace" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldNamespace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespace: %w", err)
	}
	return oldValue.Namespace, nil
}

// ResetNamespace resets all changes to the "namespace" field.
func (m *FileMutation) ResetNamespace() {
	m.namespace = nil
}

// SetPod sets the "pod" field.
func (m *FileMutation) SetPod(s string) {
	m.pod = &s
}

// Pod returns the value of the "pod" field in the mutation.
func (m *FileMutation) Pod() (r string, exists bool) {
	v := m.pod
	if v == nil {
		return
	}
	return *v, true
}

// OldPod returns the old "pod" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPod: %w", err)
	}
	return oldValue.Pod, nil
}

// ResetPod resets all changes to the "pod" field.
func (m *FileMutation) ResetPod() {
	m.pod = nil
}

// SetContainer sets the "container" field.
func (m *FileMutation) SetContainer(s string) {
	m.container = &s
}

// Container returns the value of the "container" field in the mutation.
func (m *FileMutation) Container() (r string, exists bool) {
	v := m.container
	if v == nil {
		return
	}
	return *v, true
}

// OldContainer returns the old "container" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContainer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainer: %w", err)
	}
	return oldValue.Container, nil
}

// ResetContainer resets all changes to the "container" field.
func (m *FileMutation) ResetContainer() {
	m.container = nil
}

// SetContainerPath sets the "container_path" field.
func (m *FileMutation) SetContainerPath(s string) {
	m.container_path = &s
}

// ContainerPath returns the value of the "container_path" field in the mutation.
func (m *FileMutation) ContainerPath() (r string, exists bool) {
	v := m.container_path
	if v == nil {
		return
	}
	return *v, true
}

// OldContainerPath returns the old "container_path" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldContainerPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContainerPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContainerPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContainerPath: %w", err)
	}
	return oldValue.ContainerPath, nil
}

// ResetContainerPath resets all changes to the "container_path" field.
func (m *FileMutation) ResetContainerPath() {
	m.container_path = nil
}

// AddEventIDs adds the "events" edge to the Event entity by ids.
func (m *FileMutation) AddEventIDs(ids ...int) {
	if m.events == nil {
		m.events = make(map[int]struct{})
	}
	for i := range ids {
		m.events[ids[i]] = struct{}{}
	}
}

// ClearEvents clears the "events" edge to the Event entity.
func (m *FileMutation) ClearEvents() {
	m.clearedevents = true
}

// EventsCleared reports if the "events" edge to the Event entity was cleared.
func (m *FileMutation) EventsCleared() bool {
	return m.clearedevents
}

// RemoveEventIDs removes the "events" edge to the Event entity by IDs.
func (m *FileMutation) RemoveEventIDs(ids ...int) {
	if m.removedevents == nil {
		m.removedevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.events, ids[i])
		m.removedevents[ids[i]] = struct{}{}
	}
}

// RemovedEvents returns the removed IDs of the "events" edge to the Event entity.
func (m *FileMutation) RemovedEventsIDs() (ids []int) {
	for id := range m.removedevents {
		ids = append(ids, id)
	}
	return
}

// EventsIDs returns the "events" edge IDs in the mutation.
func (m *FileMutation) EventsIDs() (ids []int) {
	for id := range m.events {
		ids = append(ids, id)
	}
	return
}

// ResetEvents resets all changes to the "events" edge.
func (m *FileMutation) ResetEvents() {
	m.events = nil
	m.clearedevents = false
	m.removedevents = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.upload_type != nil {
		fields = append(fields, file.FieldUploadType)
	}
	if m._path != nil {
		fields = append(fields, file.FieldPath)
	}
	if m.size != nil {
		fields = append(fields, file.FieldSize)
	}
	if m.username != nil {
		fields = append(fields, file.FieldUsername)
	}
	if m.namespace != nil {
		fields = append(fields, file.FieldNamespace)
	}
	if m.pod != nil {
		fields = append(fields, file.FieldPod)
	}
	if m.container != nil {
		fields = append(fields, file.FieldContainer)
	}
	if m.container_path != nil {
		fields = append(fields, file.FieldContainerPath)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldUploadType:
		return m.UploadType()
	case file.FieldPath:
		return m.Path()
	case file.FieldSize:
		return m.Size()
	case file.FieldUsername:
		return m.Username()
	case file.FieldNamespace:
		return m.Namespace()
	case file.FieldPod:
		return m.Pod()
	case file.FieldContainer:
		return m.Container()
	case file.FieldContainerPath:
		return m.ContainerPath()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldUploadType:
		return m.OldUploadType(ctx)
	case file.FieldPath:
		return m.OldPath(ctx)
	case file.FieldSize:
		return m.OldSize(ctx)
	case file.FieldUsername:
		return m.OldUsername(ctx)
	case file.FieldNamespace:
		return m.OldNamespace(ctx)
	case file.FieldPod:
		return m.OldPod(ctx)
	case file.FieldContainer:
		return m.OldContainer(ctx)
	case file.FieldContainerPath:
		return m.OldContainerPath(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldUploadType:
		v, ok := value.(schematype.UploadType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadType(v)
		return nil
	case file.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case file.FieldSize:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case file.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case file.FieldNamespace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespace(v)
		return nil
	case file.FieldPod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPod(v)
		return nil
	case file.FieldContainer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainer(v)
		return nil
	case file.FieldContainerPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContainerPath(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, file.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldUploadType:
		m.ResetUploadType()
		return nil
	case file.FieldPath:
		m.ResetPath()
		return nil
	case file.FieldSize:
		m.ResetSize()
		return nil
	case file.FieldUsername:
		m.ResetUsername()
		return nil
	case file.FieldNamespace:
		m.ResetNamespace()
		return nil
	case file.FieldPod:
		m.ResetPod()
		return nil
	case file.FieldContainer:
		m.ResetContainer()
		return nil
	case file.FieldContainerPath:
		m.ResetContainerPath()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.events != nil {
		edges = append(edges, file.EdgeEvents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.events))
		for id := range m.events {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedevents != nil {
		edges = append(edges, file.EdgeEvents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeEvents:
		ids := make([]ent.Value, 0, len(m.removedevents))
		for id := range m.removedevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedevents {
		edges = append(edges, file.EdgeEvents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeEvents:
		return m.clearedevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// NamespaceMutation represents an operation that mutates the Namespace nodes in the graph.
type NamespaceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	image_pull_secrets       *[]string
	appendimage_pull_secrets []string
	description              *string
	clearedFields            map[string]struct{}
	projects                 map[int]struct{}
	removedprojects          map[int]struct{}
	clearedprojects          bool
	favorites                map[int]struct{}
	removedfavorites         map[int]struct{}
	clearedfavorites         bool
	done                     bool
	oldValue                 func(context.Context) (*Namespace, error)
	predicates               []predicate.Namespace
}

var _ ent.Mutation = (*NamespaceMutation)(nil)

// namespaceOption allows management of the mutation configuration using functional options.
type namespaceOption func(*NamespaceMutation)

// newNamespaceMutation creates new mutation for the Namespace entity.
func newNamespaceMutation(c config, op Op, opts ...namespaceOption) *NamespaceMutation {
	m := &NamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceID sets the ID field of the mutation.
func withNamespaceID(id int) namespaceOption {
	return func(m *NamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Namespace
		)
		m.oldValue = func(ctx context.Context) (*Namespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Namespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespace sets the old Namespace of the mutation.
func withNamespace(node *Namespace) namespaceOption {
	return func(m *NamespaceMutation) {
		m.oldValue = func(context.Context) (*Namespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamespaceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Namespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NamespaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NamespaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NamespaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NamespaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NamespaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NamespaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *NamespaceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *NamespaceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *NamespaceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[namespace.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *NamespaceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[namespace.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *NamespaceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, namespace.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *NamespaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NamespaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NamespaceMutation) ResetName() {
	m.name = nil
}

// SetImagePullSecrets sets the "image_pull_secrets" field.
func (m *NamespaceMutation) SetImagePullSecrets(s []string) {
	m.image_pull_secrets = &s
	m.appendimage_pull_secrets = nil
}

// ImagePullSecrets returns the value of the "image_pull_secrets" field in the mutation.
func (m *NamespaceMutation) ImagePullSecrets() (r []string, exists bool) {
	v := m.image_pull_secrets
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePullSecrets returns the old "image_pull_secrets" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldImagePullSecrets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePullSecrets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePullSecrets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePullSecrets: %w", err)
	}
	return oldValue.ImagePullSecrets, nil
}

// AppendImagePullSecrets adds s to the "image_pull_secrets" field.
func (m *NamespaceMutation) AppendImagePullSecrets(s []string) {
	m.appendimage_pull_secrets = append(m.appendimage_pull_secrets, s...)
}

// AppendedImagePullSecrets returns the list of values that were appended to the "image_pull_secrets" field in this mutation.
func (m *NamespaceMutation) AppendedImagePullSecrets() ([]string, bool) {
	if len(m.appendimage_pull_secrets) == 0 {
		return nil, false
	}
	return m.appendimage_pull_secrets, true
}

// ResetImagePullSecrets resets all changes to the "image_pull_secrets" field.
func (m *NamespaceMutation) ResetImagePullSecrets() {
	m.image_pull_secrets = nil
	m.appendimage_pull_secrets = nil
}

// SetDescription sets the "description" field.
func (m *NamespaceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *NamespaceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *NamespaceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[namespace.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *NamespaceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[namespace.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *NamespaceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, namespace.FieldDescription)
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *NamespaceMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *NamespaceMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *NamespaceMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *NamespaceMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *NamespaceMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *NamespaceMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *NamespaceMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddFavoriteIDs adds the "favorites" edge to the Favorite entity by ids.
func (m *NamespaceMutation) AddFavoriteIDs(ids ...int) {
	if m.favorites == nil {
		m.favorites = make(map[int]struct{})
	}
	for i := range ids {
		m.favorites[ids[i]] = struct{}{}
	}
}

// ClearFavorites clears the "favorites" edge to the Favorite entity.
func (m *NamespaceMutation) ClearFavorites() {
	m.clearedfavorites = true
}

// FavoritesCleared reports if the "favorites" edge to the Favorite entity was cleared.
func (m *NamespaceMutation) FavoritesCleared() bool {
	return m.clearedfavorites
}

// RemoveFavoriteIDs removes the "favorites" edge to the Favorite entity by IDs.
func (m *NamespaceMutation) RemoveFavoriteIDs(ids ...int) {
	if m.removedfavorites == nil {
		m.removedfavorites = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.favorites, ids[i])
		m.removedfavorites[ids[i]] = struct{}{}
	}
}

// RemovedFavorites returns the removed IDs of the "favorites" edge to the Favorite entity.
func (m *NamespaceMutation) RemovedFavoritesIDs() (ids []int) {
	for id := range m.removedfavorites {
		ids = append(ids, id)
	}
	return
}

// FavoritesIDs returns the "favorites" edge IDs in the mutation.
func (m *NamespaceMutation) FavoritesIDs() (ids []int) {
	for id := range m.favorites {
		ids = append(ids, id)
	}
	return
}

// ResetFavorites resets all changes to the "favorites" edge.
func (m *NamespaceMutation) ResetFavorites() {
	m.favorites = nil
	m.clearedfavorites = false
	m.removedfavorites = nil
}

// Where appends a list predicates to the NamespaceMutation builder.
func (m *NamespaceMutation) Where(ps ...predicate.Namespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Namespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Namespace).
func (m *NamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, namespace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, namespace.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, namespace.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, namespace.FieldName)
	}
	if m.image_pull_secrets != nil {
		fields = append(fields, namespace.FieldImagePullSecrets)
	}
	if m.description != nil {
		fields = append(fields, namespace.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.CreatedAt()
	case namespace.FieldUpdatedAt:
		return m.UpdatedAt()
	case namespace.FieldDeletedAt:
		return m.DeletedAt()
	case namespace.FieldName:
		return m.Name()
	case namespace.FieldImagePullSecrets:
		return m.ImagePullSecrets()
	case namespace.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case namespace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case namespace.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case namespace.FieldName:
		return m.OldName(ctx)
	case namespace.FieldImagePullSecrets:
		return m.OldImagePullSecrets(ctx)
	case namespace.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Namespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case namespace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case namespace.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case namespace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case namespace.FieldImagePullSecrets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePullSecrets(v)
		return nil
	case namespace.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(namespace.FieldDeletedAt) {
		fields = append(fields, namespace.FieldDeletedAt)
	}
	if m.FieldCleared(namespace.FieldDescription) {
		fields = append(fields, namespace.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceMutation) ClearField(name string) error {
	switch name {
	case namespace.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case namespace.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Namespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceMutation) ResetField(name string) error {
	switch name {
	case namespace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case namespace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case namespace.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case namespace.FieldName:
		m.ResetName()
		return nil
	case namespace.FieldImagePullSecrets:
		m.ResetImagePullSecrets()
		return nil
	case namespace.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.projects != nil {
		edges = append(edges, namespace.EdgeProjects)
	}
	if m.favorites != nil {
		edges = append(edges, namespace.EdgeFavorites)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.favorites))
		for id := range m.favorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedprojects != nil {
		edges = append(edges, namespace.EdgeProjects)
	}
	if m.removedfavorites != nil {
		edges = append(edges, namespace.EdgeFavorites)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeFavorites:
		ids := make([]ent.Value, 0, len(m.removedfavorites))
		for id := range m.removedfavorites {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedprojects {
		edges = append(edges, namespace.EdgeProjects)
	}
	if m.clearedfavorites {
		edges = append(edges, namespace.EdgeFavorites)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case namespace.EdgeProjects:
		return m.clearedprojects
	case namespace.EdgeFavorites:
		return m.clearedfavorites
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceMutation) ResetEdge(name string) error {
	switch name {
	case namespace.EdgeProjects:
		m.ResetProjects()
		return nil
	case namespace.EdgeFavorites:
		m.ResetFavorites()
		return nil
	}
	return fmt.Errorf("unknown Namespace edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	name                     *string
	git_project_id           *int
	addgit_project_id        *int
	git_branch               *string
	git_commit               *string
	_config                  *string
	creator                  *string
	override_values          *string
	docker_image             *[]string
	appenddocker_image       []string
	pod_selectors            *[]string
	appendpod_selectors      []string
	atomic                   *bool
	deploy_status            *types.Deploy
	adddeploy_status         *types.Deploy
	env_values               *[]*types.KeyValue
	appendenv_values         []*types.KeyValue
	extra_values             *[]*websocket.ExtraValue
	appendextra_values       []*websocket.ExtraValue
	final_extra_values       *[]*websocket.ExtraValue
	appendfinal_extra_values []*websocket.ExtraValue
	version                  *int
	addversion               *int
	config_type              *string
	manifest                 *[]string
	appendmanifest           []string
	git_commit_web_url       *string
	git_commit_title         *string
	git_commit_author        *string
	git_commit_date          *time.Time
	clearedFields            map[string]struct{}
	changelogs               map[int]struct{}
	removedchangelogs        map[int]struct{}
	clearedchangelogs        bool
	repo                     *int
	clearedrepo              bool
	namespace                *int
	clearednamespace         bool
	done                     bool
	oldValue                 func(context.Context) (*Project, error)
	predicates               []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProjectMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProjectMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProjectMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[project.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProjectMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[project.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProjectMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, project.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetGitProjectID sets the "git_project_id" field.
func (m *ProjectMutation) SetGitProjectID(i int) {
	m.git_project_id = &i
	m.addgit_project_id = nil
}

// GitProjectID returns the value of the "git_project_id" field in the mutation.
func (m *ProjectMutation) GitProjectID() (r int, exists bool) {
	v := m.git_project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGitProjectID returns the old "git_project_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitProjectID: %w", err)
	}
	return oldValue.GitProjectID, nil
}

// AddGitProjectID adds i to the "git_project_id" field.
func (m *ProjectMutation) AddGitProjectID(i int) {
	if m.addgit_project_id != nil {
		*m.addgit_project_id += i
	} else {
		m.addgit_project_id = &i
	}
}

// AddedGitProjectID returns the value that was added to the "git_project_id" field in this mutation.
func (m *ProjectMutation) AddedGitProjectID() (r int, exists bool) {
	v := m.addgit_project_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetGitProjectID resets all changes to the "git_project_id" field.
func (m *ProjectMutation) ResetGitProjectID() {
	m.git_project_id = nil
	m.addgit_project_id = nil
}

// SetGitBranch sets the "git_branch" field.
func (m *ProjectMutation) SetGitBranch(s string) {
	m.git_branch = &s
}

// GitBranch returns the value of the "git_branch" field in the mutation.
func (m *ProjectMutation) GitBranch() (r string, exists bool) {
	v := m.git_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldGitBranch returns the old "git_branch" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitBranch: %w", err)
	}
	return oldValue.GitBranch, nil
}

// ResetGitBranch resets all changes to the "git_branch" field.
func (m *ProjectMutation) ResetGitBranch() {
	m.git_branch = nil
}

// SetGitCommit sets the "git_commit" field.
func (m *ProjectMutation) SetGitCommit(s string) {
	m.git_commit = &s
}

// GitCommit returns the value of the "git_commit" field in the mutation.
func (m *ProjectMutation) GitCommit() (r string, exists bool) {
	v := m.git_commit
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommit returns the old "git_commit" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommit: %w", err)
	}
	return oldValue.GitCommit, nil
}

// ResetGitCommit resets all changes to the "git_commit" field.
func (m *ProjectMutation) ResetGitCommit() {
	m.git_commit = nil
}

// SetConfig sets the "config" field.
func (m *ProjectMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *ProjectMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ClearConfig clears the value of the "config" field.
func (m *ProjectMutation) ClearConfig() {
	m._config = nil
	m.clearedFields[project.FieldConfig] = struct{}{}
}

// ConfigCleared returns if the "config" field was cleared in this mutation.
func (m *ProjectMutation) ConfigCleared() bool {
	_, ok := m.clearedFields[project.FieldConfig]
	return ok
}

// ResetConfig resets all changes to the "config" field.
func (m *ProjectMutation) ResetConfig() {
	m._config = nil
	delete(m.clearedFields, project.FieldConfig)
}

// SetCreator sets the "creator" field.
func (m *ProjectMutation) SetCreator(s string) {
	m.creator = &s
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ProjectMutation) Creator() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ResetCreator resets all changes to the "creator" field.
func (m *ProjectMutation) ResetCreator() {
	m.creator = nil
}

// SetOverrideValues sets the "override_values" field.
func (m *ProjectMutation) SetOverrideValues(s string) {
	m.override_values = &s
}

// OverrideValues returns the value of the "override_values" field in the mutation.
func (m *ProjectMutation) OverrideValues() (r string, exists bool) {
	v := m.override_values
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideValues returns the old "override_values" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldOverrideValues(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideValues: %w", err)
	}
	return oldValue.OverrideValues, nil
}

// ClearOverrideValues clears the value of the "override_values" field.
func (m *ProjectMutation) ClearOverrideValues() {
	m.override_values = nil
	m.clearedFields[project.FieldOverrideValues] = struct{}{}
}

// OverrideValuesCleared returns if the "override_values" field was cleared in this mutation.
func (m *ProjectMutation) OverrideValuesCleared() bool {
	_, ok := m.clearedFields[project.FieldOverrideValues]
	return ok
}

// ResetOverrideValues resets all changes to the "override_values" field.
func (m *ProjectMutation) ResetOverrideValues() {
	m.override_values = nil
	delete(m.clearedFields, project.FieldOverrideValues)
}

// SetDockerImage sets the "docker_image" field.
func (m *ProjectMutation) SetDockerImage(s []string) {
	m.docker_image = &s
	m.appenddocker_image = nil
}

// DockerImage returns the value of the "docker_image" field in the mutation.
func (m *ProjectMutation) DockerImage() (r []string, exists bool) {
	v := m.docker_image
	if v == nil {
		return
	}
	return *v, true
}

// OldDockerImage returns the old "docker_image" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDockerImage(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDockerImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDockerImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDockerImage: %w", err)
	}
	return oldValue.DockerImage, nil
}

// AppendDockerImage adds s to the "docker_image" field.
func (m *ProjectMutation) AppendDockerImage(s []string) {
	m.appenddocker_image = append(m.appenddocker_image, s...)
}

// AppendedDockerImage returns the list of values that were appended to the "docker_image" field in this mutation.
func (m *ProjectMutation) AppendedDockerImage() ([]string, bool) {
	if len(m.appenddocker_image) == 0 {
		return nil, false
	}
	return m.appenddocker_image, true
}

// ClearDockerImage clears the value of the "docker_image" field.
func (m *ProjectMutation) ClearDockerImage() {
	m.docker_image = nil
	m.appenddocker_image = nil
	m.clearedFields[project.FieldDockerImage] = struct{}{}
}

// DockerImageCleared returns if the "docker_image" field was cleared in this mutation.
func (m *ProjectMutation) DockerImageCleared() bool {
	_, ok := m.clearedFields[project.FieldDockerImage]
	return ok
}

// ResetDockerImage resets all changes to the "docker_image" field.
func (m *ProjectMutation) ResetDockerImage() {
	m.docker_image = nil
	m.appenddocker_image = nil
	delete(m.clearedFields, project.FieldDockerImage)
}

// SetPodSelectors sets the "pod_selectors" field.
func (m *ProjectMutation) SetPodSelectors(s []string) {
	m.pod_selectors = &s
	m.appendpod_selectors = nil
}

// PodSelectors returns the value of the "pod_selectors" field in the mutation.
func (m *ProjectMutation) PodSelectors() (r []string, exists bool) {
	v := m.pod_selectors
	if v == nil {
		return
	}
	return *v, true
}

// OldPodSelectors returns the old "pod_selectors" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldPodSelectors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPodSelectors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPodSelectors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPodSelectors: %w", err)
	}
	return oldValue.PodSelectors, nil
}

// AppendPodSelectors adds s to the "pod_selectors" field.
func (m *ProjectMutation) AppendPodSelectors(s []string) {
	m.appendpod_selectors = append(m.appendpod_selectors, s...)
}

// AppendedPodSelectors returns the list of values that were appended to the "pod_selectors" field in this mutation.
func (m *ProjectMutation) AppendedPodSelectors() ([]string, bool) {
	if len(m.appendpod_selectors) == 0 {
		return nil, false
	}
	return m.appendpod_selectors, true
}

// ClearPodSelectors clears the value of the "pod_selectors" field.
func (m *ProjectMutation) ClearPodSelectors() {
	m.pod_selectors = nil
	m.appendpod_selectors = nil
	m.clearedFields[project.FieldPodSelectors] = struct{}{}
}

// PodSelectorsCleared returns if the "pod_selectors" field was cleared in this mutation.
func (m *ProjectMutation) PodSelectorsCleared() bool {
	_, ok := m.clearedFields[project.FieldPodSelectors]
	return ok
}

// ResetPodSelectors resets all changes to the "pod_selectors" field.
func (m *ProjectMutation) ResetPodSelectors() {
	m.pod_selectors = nil
	m.appendpod_selectors = nil
	delete(m.clearedFields, project.FieldPodSelectors)
}

// SetAtomic sets the "atomic" field.
func (m *ProjectMutation) SetAtomic(b bool) {
	m.atomic = &b
}

// Atomic returns the value of the "atomic" field in the mutation.
func (m *ProjectMutation) Atomic() (r bool, exists bool) {
	v := m.atomic
	if v == nil {
		return
	}
	return *v, true
}

// OldAtomic returns the old "atomic" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldAtomic(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAtomic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAtomic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAtomic: %w", err)
	}
	return oldValue.Atomic, nil
}

// ResetAtomic resets all changes to the "atomic" field.
func (m *ProjectMutation) ResetAtomic() {
	m.atomic = nil
}

// SetDeployStatus sets the "deploy_status" field.
func (m *ProjectMutation) SetDeployStatus(t types.Deploy) {
	m.deploy_status = &t
	m.adddeploy_status = nil
}

// DeployStatus returns the value of the "deploy_status" field in the mutation.
func (m *ProjectMutation) DeployStatus() (r types.Deploy, exists bool) {
	v := m.deploy_status
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployStatus returns the old "deploy_status" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDeployStatus(ctx context.Context) (v types.Deploy, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployStatus: %w", err)
	}
	return oldValue.DeployStatus, nil
}

// AddDeployStatus adds t to the "deploy_status" field.
func (m *ProjectMutation) AddDeployStatus(t types.Deploy) {
	if m.adddeploy_status != nil {
		*m.adddeploy_status += t
	} else {
		m.adddeploy_status = &t
	}
}

// AddedDeployStatus returns the value that was added to the "deploy_status" field in this mutation.
func (m *ProjectMutation) AddedDeployStatus() (r types.Deploy, exists bool) {
	v := m.adddeploy_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeployStatus resets all changes to the "deploy_status" field.
func (m *ProjectMutation) ResetDeployStatus() {
	m.deploy_status = nil
	m.adddeploy_status = nil
}

// SetEnvValues sets the "env_values" field.
func (m *ProjectMutation) SetEnvValues(tv []*types.KeyValue) {
	m.env_values = &tv
	m.appendenv_values = nil
}

// EnvValues returns the value of the "env_values" field in the mutation.
func (m *ProjectMutation) EnvValues() (r []*types.KeyValue, exists bool) {
	v := m.env_values
	if v == nil {
		return
	}
	return *v, true
}

// OldEnvValues returns the old "env_values" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEnvValues(ctx context.Context) (v []*types.KeyValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnvValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnvValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnvValues: %w", err)
	}
	return oldValue.EnvValues, nil
}

// AppendEnvValues adds tv to the "env_values" field.
func (m *ProjectMutation) AppendEnvValues(tv []*types.KeyValue) {
	m.appendenv_values = append(m.appendenv_values, tv...)
}

// AppendedEnvValues returns the list of values that were appended to the "env_values" field in this mutation.
func (m *ProjectMutation) AppendedEnvValues() ([]*types.KeyValue, bool) {
	if len(m.appendenv_values) == 0 {
		return nil, false
	}
	return m.appendenv_values, true
}

// ClearEnvValues clears the value of the "env_values" field.
func (m *ProjectMutation) ClearEnvValues() {
	m.env_values = nil
	m.appendenv_values = nil
	m.clearedFields[project.FieldEnvValues] = struct{}{}
}

// EnvValuesCleared returns if the "env_values" field was cleared in this mutation.
func (m *ProjectMutation) EnvValuesCleared() bool {
	_, ok := m.clearedFields[project.FieldEnvValues]
	return ok
}

// ResetEnvValues resets all changes to the "env_values" field.
func (m *ProjectMutation) ResetEnvValues() {
	m.env_values = nil
	m.appendenv_values = nil
	delete(m.clearedFields, project.FieldEnvValues)
}

// SetExtraValues sets the "extra_values" field.
func (m *ProjectMutation) SetExtraValues(wv []*websocket.ExtraValue) {
	m.extra_values = &wv
	m.appendextra_values = nil
}

// ExtraValues returns the value of the "extra_values" field in the mutation.
func (m *ProjectMutation) ExtraValues() (r []*websocket.ExtraValue, exists bool) {
	v := m.extra_values
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraValues returns the old "extra_values" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldExtraValues(ctx context.Context) (v []*websocket.ExtraValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraValues: %w", err)
	}
	return oldValue.ExtraValues, nil
}

// AppendExtraValues adds wv to the "extra_values" field.
func (m *ProjectMutation) AppendExtraValues(wv []*websocket.ExtraValue) {
	m.appendextra_values = append(m.appendextra_values, wv...)
}

// AppendedExtraValues returns the list of values that were appended to the "extra_values" field in this mutation.
func (m *ProjectMutation) AppendedExtraValues() ([]*websocket.ExtraValue, bool) {
	if len(m.appendextra_values) == 0 {
		return nil, false
	}
	return m.appendextra_values, true
}

// ClearExtraValues clears the value of the "extra_values" field.
func (m *ProjectMutation) ClearExtraValues() {
	m.extra_values = nil
	m.appendextra_values = nil
	m.clearedFields[project.FieldExtraValues] = struct{}{}
}

// ExtraValuesCleared returns if the "extra_values" field was cleared in this mutation.
func (m *ProjectMutation) ExtraValuesCleared() bool {
	_, ok := m.clearedFields[project.FieldExtraValues]
	return ok
}

// ResetExtraValues resets all changes to the "extra_values" field.
func (m *ProjectMutation) ResetExtraValues() {
	m.extra_values = nil
	m.appendextra_values = nil
	delete(m.clearedFields, project.FieldExtraValues)
}

// SetFinalExtraValues sets the "final_extra_values" field.
func (m *ProjectMutation) SetFinalExtraValues(wv []*websocket.ExtraValue) {
	m.final_extra_values = &wv
	m.appendfinal_extra_values = nil
}

// FinalExtraValues returns the value of the "final_extra_values" field in the mutation.
func (m *ProjectMutation) FinalExtraValues() (r []*websocket.ExtraValue, exists bool) {
	v := m.final_extra_values
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalExtraValues returns the old "final_extra_values" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldFinalExtraValues(ctx context.Context) (v []*websocket.ExtraValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinalExtraValues is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinalExtraValues requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalExtraValues: %w", err)
	}
	return oldValue.FinalExtraValues, nil
}

// AppendFinalExtraValues adds wv to the "final_extra_values" field.
func (m *ProjectMutation) AppendFinalExtraValues(wv []*websocket.ExtraValue) {
	m.appendfinal_extra_values = append(m.appendfinal_extra_values, wv...)
}

// AppendedFinalExtraValues returns the list of values that were appended to the "final_extra_values" field in this mutation.
func (m *ProjectMutation) AppendedFinalExtraValues() ([]*websocket.ExtraValue, bool) {
	if len(m.appendfinal_extra_values) == 0 {
		return nil, false
	}
	return m.appendfinal_extra_values, true
}

// ClearFinalExtraValues clears the value of the "final_extra_values" field.
func (m *ProjectMutation) ClearFinalExtraValues() {
	m.final_extra_values = nil
	m.appendfinal_extra_values = nil
	m.clearedFields[project.FieldFinalExtraValues] = struct{}{}
}

// FinalExtraValuesCleared returns if the "final_extra_values" field was cleared in this mutation.
func (m *ProjectMutation) FinalExtraValuesCleared() bool {
	_, ok := m.clearedFields[project.FieldFinalExtraValues]
	return ok
}

// ResetFinalExtraValues resets all changes to the "final_extra_values" field.
func (m *ProjectMutation) ResetFinalExtraValues() {
	m.final_extra_values = nil
	m.appendfinal_extra_values = nil
	delete(m.clearedFields, project.FieldFinalExtraValues)
}

// SetVersion sets the "version" field.
func (m *ProjectMutation) SetVersion(i int) {
	m.version = &i
	m.addversion = nil
}

// Version returns the value of the "version" field in the mutation.
func (m *ProjectMutation) Version() (r int, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldVersion(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// AddVersion adds i to the "version" field.
func (m *ProjectMutation) AddVersion(i int) {
	if m.addversion != nil {
		*m.addversion += i
	} else {
		m.addversion = &i
	}
}

// AddedVersion returns the value that was added to the "version" field in this mutation.
func (m *ProjectMutation) AddedVersion() (r int, exists bool) {
	v := m.addversion
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersion resets all changes to the "version" field.
func (m *ProjectMutation) ResetVersion() {
	m.version = nil
	m.addversion = nil
}

// SetConfigType sets the "config_type" field.
func (m *ProjectMutation) SetConfigType(s string) {
	m.config_type = &s
}

// ConfigType returns the value of the "config_type" field in the mutation.
func (m *ProjectMutation) ConfigType() (r string, exists bool) {
	v := m.config_type
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigType returns the old "config_type" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldConfigType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigType: %w", err)
	}
	return oldValue.ConfigType, nil
}

// ClearConfigType clears the value of the "config_type" field.
func (m *ProjectMutation) ClearConfigType() {
	m.config_type = nil
	m.clearedFields[project.FieldConfigType] = struct{}{}
}

// ConfigTypeCleared returns if the "config_type" field was cleared in this mutation.
func (m *ProjectMutation) ConfigTypeCleared() bool {
	_, ok := m.clearedFields[project.FieldConfigType]
	return ok
}

// ResetConfigType resets all changes to the "config_type" field.
func (m *ProjectMutation) ResetConfigType() {
	m.config_type = nil
	delete(m.clearedFields, project.FieldConfigType)
}

// SetManifest sets the "manifest" field.
func (m *ProjectMutation) SetManifest(s []string) {
	m.manifest = &s
	m.appendmanifest = nil
}

// Manifest returns the value of the "manifest" field in the mutation.
func (m *ProjectMutation) Manifest() (r []string, exists bool) {
	v := m.manifest
	if v == nil {
		return
	}
	return *v, true
}

// OldManifest returns the old "manifest" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldManifest(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManifest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManifest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManifest: %w", err)
	}
	return oldValue.Manifest, nil
}

// AppendManifest adds s to the "manifest" field.
func (m *ProjectMutation) AppendManifest(s []string) {
	m.appendmanifest = append(m.appendmanifest, s...)
}

// AppendedManifest returns the list of values that were appended to the "manifest" field in this mutation.
func (m *ProjectMutation) AppendedManifest() ([]string, bool) {
	if len(m.appendmanifest) == 0 {
		return nil, false
	}
	return m.appendmanifest, true
}

// ClearManifest clears the value of the "manifest" field.
func (m *ProjectMutation) ClearManifest() {
	m.manifest = nil
	m.appendmanifest = nil
	m.clearedFields[project.FieldManifest] = struct{}{}
}

// ManifestCleared returns if the "manifest" field was cleared in this mutation.
func (m *ProjectMutation) ManifestCleared() bool {
	_, ok := m.clearedFields[project.FieldManifest]
	return ok
}

// ResetManifest resets all changes to the "manifest" field.
func (m *ProjectMutation) ResetManifest() {
	m.manifest = nil
	m.appendmanifest = nil
	delete(m.clearedFields, project.FieldManifest)
}

// SetGitCommitWebURL sets the "git_commit_web_url" field.
func (m *ProjectMutation) SetGitCommitWebURL(s string) {
	m.git_commit_web_url = &s
}

// GitCommitWebURL returns the value of the "git_commit_web_url" field in the mutation.
func (m *ProjectMutation) GitCommitWebURL() (r string, exists bool) {
	v := m.git_commit_web_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitWebURL returns the old "git_commit_web_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommitWebURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitWebURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitWebURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitWebURL: %w", err)
	}
	return oldValue.GitCommitWebURL, nil
}

// ResetGitCommitWebURL resets all changes to the "git_commit_web_url" field.
func (m *ProjectMutation) ResetGitCommitWebURL() {
	m.git_commit_web_url = nil
}

// SetGitCommitTitle sets the "git_commit_title" field.
func (m *ProjectMutation) SetGitCommitTitle(s string) {
	m.git_commit_title = &s
}

// GitCommitTitle returns the value of the "git_commit_title" field in the mutation.
func (m *ProjectMutation) GitCommitTitle() (r string, exists bool) {
	v := m.git_commit_title
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitTitle returns the old "git_commit_title" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommitTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitTitle: %w", err)
	}
	return oldValue.GitCommitTitle, nil
}

// ResetGitCommitTitle resets all changes to the "git_commit_title" field.
func (m *ProjectMutation) ResetGitCommitTitle() {
	m.git_commit_title = nil
}

// SetGitCommitAuthor sets the "git_commit_author" field.
func (m *ProjectMutation) SetGitCommitAuthor(s string) {
	m.git_commit_author = &s
}

// GitCommitAuthor returns the value of the "git_commit_author" field in the mutation.
func (m *ProjectMutation) GitCommitAuthor() (r string, exists bool) {
	v := m.git_commit_author
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitAuthor returns the old "git_commit_author" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommitAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitAuthor: %w", err)
	}
	return oldValue.GitCommitAuthor, nil
}

// ResetGitCommitAuthor resets all changes to the "git_commit_author" field.
func (m *ProjectMutation) ResetGitCommitAuthor() {
	m.git_commit_author = nil
}

// SetGitCommitDate sets the "git_commit_date" field.
func (m *ProjectMutation) SetGitCommitDate(t time.Time) {
	m.git_commit_date = &t
}

// GitCommitDate returns the value of the "git_commit_date" field in the mutation.
func (m *ProjectMutation) GitCommitDate() (r time.Time, exists bool) {
	v := m.git_commit_date
	if v == nil {
		return
	}
	return *v, true
}

// OldGitCommitDate returns the old "git_commit_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGitCommitDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitCommitDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitCommitDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitCommitDate: %w", err)
	}
	return oldValue.GitCommitDate, nil
}

// ClearGitCommitDate clears the value of the "git_commit_date" field.
func (m *ProjectMutation) ClearGitCommitDate() {
	m.git_commit_date = nil
	m.clearedFields[project.FieldGitCommitDate] = struct{}{}
}

// GitCommitDateCleared returns if the "git_commit_date" field was cleared in this mutation.
func (m *ProjectMutation) GitCommitDateCleared() bool {
	_, ok := m.clearedFields[project.FieldGitCommitDate]
	return ok
}

// ResetGitCommitDate resets all changes to the "git_commit_date" field.
func (m *ProjectMutation) ResetGitCommitDate() {
	m.git_commit_date = nil
	delete(m.clearedFields, project.FieldGitCommitDate)
}

// SetNamespaceID sets the "namespace_id" field.
func (m *ProjectMutation) SetNamespaceID(i int) {
	m.namespace = &i
}

// NamespaceID returns the value of the "namespace_id" field in the mutation.
func (m *ProjectMutation) NamespaceID() (r int, exists bool) {
	v := m.namespace
	if v == nil {
		return
	}
	return *v, true
}

// OldNamespaceID returns the old "namespace_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldNamespaceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNamespaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNamespaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNamespaceID: %w", err)
	}
	return oldValue.NamespaceID, nil
}

// ClearNamespaceID clears the value of the "namespace_id" field.
func (m *ProjectMutation) ClearNamespaceID() {
	m.namespace = nil
	m.clearedFields[project.FieldNamespaceID] = struct{}{}
}

// NamespaceIDCleared returns if the "namespace_id" field was cleared in this mutation.
func (m *ProjectMutation) NamespaceIDCleared() bool {
	_, ok := m.clearedFields[project.FieldNamespaceID]
	return ok
}

// ResetNamespaceID resets all changes to the "namespace_id" field.
func (m *ProjectMutation) ResetNamespaceID() {
	m.namespace = nil
	delete(m.clearedFields, project.FieldNamespaceID)
}

// SetRepoID sets the "repo_id" field.
func (m *ProjectMutation) SetRepoID(i int) {
	m.repo = &i
}

// RepoID returns the value of the "repo_id" field in the mutation.
func (m *ProjectMutation) RepoID() (r int, exists bool) {
	v := m.repo
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoID returns the old "repo_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldRepoID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoID: %w", err)
	}
	return oldValue.RepoID, nil
}

// ClearRepoID clears the value of the "repo_id" field.
func (m *ProjectMutation) ClearRepoID() {
	m.repo = nil
	m.clearedFields[project.FieldRepoID] = struct{}{}
}

// RepoIDCleared returns if the "repo_id" field was cleared in this mutation.
func (m *ProjectMutation) RepoIDCleared() bool {
	_, ok := m.clearedFields[project.FieldRepoID]
	return ok
}

// ResetRepoID resets all changes to the "repo_id" field.
func (m *ProjectMutation) ResetRepoID() {
	m.repo = nil
	delete(m.clearedFields, project.FieldRepoID)
}

// AddChangelogIDs adds the "changelogs" edge to the Changelog entity by ids.
func (m *ProjectMutation) AddChangelogIDs(ids ...int) {
	if m.changelogs == nil {
		m.changelogs = make(map[int]struct{})
	}
	for i := range ids {
		m.changelogs[ids[i]] = struct{}{}
	}
}

// ClearChangelogs clears the "changelogs" edge to the Changelog entity.
func (m *ProjectMutation) ClearChangelogs() {
	m.clearedchangelogs = true
}

// ChangelogsCleared reports if the "changelogs" edge to the Changelog entity was cleared.
func (m *ProjectMutation) ChangelogsCleared() bool {
	return m.clearedchangelogs
}

// RemoveChangelogIDs removes the "changelogs" edge to the Changelog entity by IDs.
func (m *ProjectMutation) RemoveChangelogIDs(ids ...int) {
	if m.removedchangelogs == nil {
		m.removedchangelogs = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.changelogs, ids[i])
		m.removedchangelogs[ids[i]] = struct{}{}
	}
}

// RemovedChangelogs returns the removed IDs of the "changelogs" edge to the Changelog entity.
func (m *ProjectMutation) RemovedChangelogsIDs() (ids []int) {
	for id := range m.removedchangelogs {
		ids = append(ids, id)
	}
	return
}

// ChangelogsIDs returns the "changelogs" edge IDs in the mutation.
func (m *ProjectMutation) ChangelogsIDs() (ids []int) {
	for id := range m.changelogs {
		ids = append(ids, id)
	}
	return
}

// ResetChangelogs resets all changes to the "changelogs" edge.
func (m *ProjectMutation) ResetChangelogs() {
	m.changelogs = nil
	m.clearedchangelogs = false
	m.removedchangelogs = nil
}

// ClearRepo clears the "repo" edge to the Repo entity.
func (m *ProjectMutation) ClearRepo() {
	m.clearedrepo = true
	m.clearedFields[project.FieldRepoID] = struct{}{}
}

// RepoCleared reports if the "repo" edge to the Repo entity was cleared.
func (m *ProjectMutation) RepoCleared() bool {
	return m.RepoIDCleared() || m.clearedrepo
}

// RepoIDs returns the "repo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RepoID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) RepoIDs() (ids []int) {
	if id := m.repo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRepo resets all changes to the "repo" edge.
func (m *ProjectMutation) ResetRepo() {
	m.repo = nil
	m.clearedrepo = false
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *ProjectMutation) ClearNamespace() {
	m.clearednamespace = true
	m.clearedFields[project.FieldNamespaceID] = struct{}{}
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *ProjectMutation) NamespaceCleared() bool {
	return m.NamespaceIDCleared() || m.clearednamespace
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) NamespaceIDs() (ids []int) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *ProjectMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.git_project_id != nil {
		fields = append(fields, project.FieldGitProjectID)
	}
	if m.git_branch != nil {
		fields = append(fields, project.FieldGitBranch)
	}
	if m.git_commit != nil {
		fields = append(fields, project.FieldGitCommit)
	}
	if m._config != nil {
		fields = append(fields, project.FieldConfig)
	}
	if m.creator != nil {
		fields = append(fields, project.FieldCreator)
	}
	if m.override_values != nil {
		fields = append(fields, project.FieldOverrideValues)
	}
	if m.docker_image != nil {
		fields = append(fields, project.FieldDockerImage)
	}
	if m.pod_selectors != nil {
		fields = append(fields, project.FieldPodSelectors)
	}
	if m.atomic != nil {
		fields = append(fields, project.FieldAtomic)
	}
	if m.deploy_status != nil {
		fields = append(fields, project.FieldDeployStatus)
	}
	if m.env_values != nil {
		fields = append(fields, project.FieldEnvValues)
	}
	if m.extra_values != nil {
		fields = append(fields, project.FieldExtraValues)
	}
	if m.final_extra_values != nil {
		fields = append(fields, project.FieldFinalExtraValues)
	}
	if m.version != nil {
		fields = append(fields, project.FieldVersion)
	}
	if m.config_type != nil {
		fields = append(fields, project.FieldConfigType)
	}
	if m.manifest != nil {
		fields = append(fields, project.FieldManifest)
	}
	if m.git_commit_web_url != nil {
		fields = append(fields, project.FieldGitCommitWebURL)
	}
	if m.git_commit_title != nil {
		fields = append(fields, project.FieldGitCommitTitle)
	}
	if m.git_commit_author != nil {
		fields = append(fields, project.FieldGitCommitAuthor)
	}
	if m.git_commit_date != nil {
		fields = append(fields, project.FieldGitCommitDate)
	}
	if m.namespace != nil {
		fields = append(fields, project.FieldNamespaceID)
	}
	if m.repo != nil {
		fields = append(fields, project.FieldRepoID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	case project.FieldDeletedAt:
		return m.DeletedAt()
	case project.FieldName:
		return m.Name()
	case project.FieldGitProjectID:
		return m.GitProjectID()
	case project.FieldGitBranch:
		return m.GitBranch()
	case project.FieldGitCommit:
		return m.GitCommit()
	case project.FieldConfig:
		return m.Config()
	case project.FieldCreator:
		return m.Creator()
	case project.FieldOverrideValues:
		return m.OverrideValues()
	case project.FieldDockerImage:
		return m.DockerImage()
	case project.FieldPodSelectors:
		return m.PodSelectors()
	case project.FieldAtomic:
		return m.Atomic()
	case project.FieldDeployStatus:
		return m.DeployStatus()
	case project.FieldEnvValues:
		return m.EnvValues()
	case project.FieldExtraValues:
		return m.ExtraValues()
	case project.FieldFinalExtraValues:
		return m.FinalExtraValues()
	case project.FieldVersion:
		return m.Version()
	case project.FieldConfigType:
		return m.ConfigType()
	case project.FieldManifest:
		return m.Manifest()
	case project.FieldGitCommitWebURL:
		return m.GitCommitWebURL()
	case project.FieldGitCommitTitle:
		return m.GitCommitTitle()
	case project.FieldGitCommitAuthor:
		return m.GitCommitAuthor()
	case project.FieldGitCommitDate:
		return m.GitCommitDate()
	case project.FieldNamespaceID:
		return m.NamespaceID()
	case project.FieldRepoID:
		return m.RepoID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case project.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldGitProjectID:
		return m.OldGitProjectID(ctx)
	case project.FieldGitBranch:
		return m.OldGitBranch(ctx)
	case project.FieldGitCommit:
		return m.OldGitCommit(ctx)
	case project.FieldConfig:
		return m.OldConfig(ctx)
	case project.FieldCreator:
		return m.OldCreator(ctx)
	case project.FieldOverrideValues:
		return m.OldOverrideValues(ctx)
	case project.FieldDockerImage:
		return m.OldDockerImage(ctx)
	case project.FieldPodSelectors:
		return m.OldPodSelectors(ctx)
	case project.FieldAtomic:
		return m.OldAtomic(ctx)
	case project.FieldDeployStatus:
		return m.OldDeployStatus(ctx)
	case project.FieldEnvValues:
		return m.OldEnvValues(ctx)
	case project.FieldExtraValues:
		return m.OldExtraValues(ctx)
	case project.FieldFinalExtraValues:
		return m.OldFinalExtraValues(ctx)
	case project.FieldVersion:
		return m.OldVersion(ctx)
	case project.FieldConfigType:
		return m.OldConfigType(ctx)
	case project.FieldManifest:
		return m.OldManifest(ctx)
	case project.FieldGitCommitWebURL:
		return m.OldGitCommitWebURL(ctx)
	case project.FieldGitCommitTitle:
		return m.OldGitCommitTitle(ctx)
	case project.FieldGitCommitAuthor:
		return m.OldGitCommitAuthor(ctx)
	case project.FieldGitCommitDate:
		return m.OldGitCommitDate(ctx)
	case project.FieldNamespaceID:
		return m.OldNamespaceID(ctx)
	case project.FieldRepoID:
		return m.OldRepoID(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case project.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldGitProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitProjectID(v)
		return nil
	case project.FieldGitBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitBranch(v)
		return nil
	case project.FieldGitCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommit(v)
		return nil
	case project.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case project.FieldCreator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case project.FieldOverrideValues:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideValues(v)
		return nil
	case project.FieldDockerImage:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDockerImage(v)
		return nil
	case project.FieldPodSelectors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPodSelectors(v)
		return nil
	case project.FieldAtomic:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAtomic(v)
		return nil
	case project.FieldDeployStatus:
		v, ok := value.(types.Deploy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployStatus(v)
		return nil
	case project.FieldEnvValues:
		v, ok := value.([]*types.KeyValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnvValues(v)
		return nil
	case project.FieldExtraValues:
		v, ok := value.([]*websocket.ExtraValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraValues(v)
		return nil
	case project.FieldFinalExtraValues:
		v, ok := value.([]*websocket.ExtraValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalExtraValues(v)
		return nil
	case project.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case project.FieldConfigType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigType(v)
		return nil
	case project.FieldManifest:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManifest(v)
		return nil
	case project.FieldGitCommitWebURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitWebURL(v)
		return nil
	case project.FieldGitCommitTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitTitle(v)
		return nil
	case project.FieldGitCommitAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitAuthor(v)
		return nil
	case project.FieldGitCommitDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitCommitDate(v)
		return nil
	case project.FieldNamespaceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNamespaceID(v)
		return nil
	case project.FieldRepoID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoID(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addgit_project_id != nil {
		fields = append(fields, project.FieldGitProjectID)
	}
	if m.adddeploy_status != nil {
		fields = append(fields, project.FieldDeployStatus)
	}
	if m.addversion != nil {
		fields = append(fields, project.FieldVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldGitProjectID:
		return m.AddedGitProjectID()
	case project.FieldDeployStatus:
		return m.AddedDeployStatus()
	case project.FieldVersion:
		return m.AddedVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldGitProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGitProjectID(v)
		return nil
	case project.FieldDeployStatus:
		v, ok := value.(types.Deploy)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeployStatus(v)
		return nil
	case project.FieldVersion:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersion(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldDeletedAt) {
		fields = append(fields, project.FieldDeletedAt)
	}
	if m.FieldCleared(project.FieldConfig) {
		fields = append(fields, project.FieldConfig)
	}
	if m.FieldCleared(project.FieldOverrideValues) {
		fields = append(fields, project.FieldOverrideValues)
	}
	if m.FieldCleared(project.FieldDockerImage) {
		fields = append(fields, project.FieldDockerImage)
	}
	if m.FieldCleared(project.FieldPodSelectors) {
		fields = append(fields, project.FieldPodSelectors)
	}
	if m.FieldCleared(project.FieldEnvValues) {
		fields = append(fields, project.FieldEnvValues)
	}
	if m.FieldCleared(project.FieldExtraValues) {
		fields = append(fields, project.FieldExtraValues)
	}
	if m.FieldCleared(project.FieldFinalExtraValues) {
		fields = append(fields, project.FieldFinalExtraValues)
	}
	if m.FieldCleared(project.FieldConfigType) {
		fields = append(fields, project.FieldConfigType)
	}
	if m.FieldCleared(project.FieldManifest) {
		fields = append(fields, project.FieldManifest)
	}
	if m.FieldCleared(project.FieldGitCommitDate) {
		fields = append(fields, project.FieldGitCommitDate)
	}
	if m.FieldCleared(project.FieldNamespaceID) {
		fields = append(fields, project.FieldNamespaceID)
	}
	if m.FieldCleared(project.FieldRepoID) {
		fields = append(fields, project.FieldRepoID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case project.FieldConfig:
		m.ClearConfig()
		return nil
	case project.FieldOverrideValues:
		m.ClearOverrideValues()
		return nil
	case project.FieldDockerImage:
		m.ClearDockerImage()
		return nil
	case project.FieldPodSelectors:
		m.ClearPodSelectors()
		return nil
	case project.FieldEnvValues:
		m.ClearEnvValues()
		return nil
	case project.FieldExtraValues:
		m.ClearExtraValues()
		return nil
	case project.FieldFinalExtraValues:
		m.ClearFinalExtraValues()
		return nil
	case project.FieldConfigType:
		m.ClearConfigType()
		return nil
	case project.FieldManifest:
		m.ClearManifest()
		return nil
	case project.FieldGitCommitDate:
		m.ClearGitCommitDate()
		return nil
	case project.FieldNamespaceID:
		m.ClearNamespaceID()
		return nil
	case project.FieldRepoID:
		m.ClearRepoID()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case project.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldGitProjectID:
		m.ResetGitProjectID()
		return nil
	case project.FieldGitBranch:
		m.ResetGitBranch()
		return nil
	case project.FieldGitCommit:
		m.ResetGitCommit()
		return nil
	case project.FieldConfig:
		m.ResetConfig()
		return nil
	case project.FieldCreator:
		m.ResetCreator()
		return nil
	case project.FieldOverrideValues:
		m.ResetOverrideValues()
		return nil
	case project.FieldDockerImage:
		m.ResetDockerImage()
		return nil
	case project.FieldPodSelectors:
		m.ResetPodSelectors()
		return nil
	case project.FieldAtomic:
		m.ResetAtomic()
		return nil
	case project.FieldDeployStatus:
		m.ResetDeployStatus()
		return nil
	case project.FieldEnvValues:
		m.ResetEnvValues()
		return nil
	case project.FieldExtraValues:
		m.ResetExtraValues()
		return nil
	case project.FieldFinalExtraValues:
		m.ResetFinalExtraValues()
		return nil
	case project.FieldVersion:
		m.ResetVersion()
		return nil
	case project.FieldConfigType:
		m.ResetConfigType()
		return nil
	case project.FieldManifest:
		m.ResetManifest()
		return nil
	case project.FieldGitCommitWebURL:
		m.ResetGitCommitWebURL()
		return nil
	case project.FieldGitCommitTitle:
		m.ResetGitCommitTitle()
		return nil
	case project.FieldGitCommitAuthor:
		m.ResetGitCommitAuthor()
		return nil
	case project.FieldGitCommitDate:
		m.ResetGitCommitDate()
		return nil
	case project.FieldNamespaceID:
		m.ResetNamespaceID()
		return nil
	case project.FieldRepoID:
		m.ResetRepoID()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.changelogs != nil {
		edges = append(edges, project.EdgeChangelogs)
	}
	if m.repo != nil {
		edges = append(edges, project.EdgeRepo)
	}
	if m.namespace != nil {
		edges = append(edges, project.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeChangelogs:
		ids := make([]ent.Value, 0, len(m.changelogs))
		for id := range m.changelogs {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeRepo:
		if id := m.repo; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchangelogs != nil {
		edges = append(edges, project.EdgeChangelogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeChangelogs:
		ids := make([]ent.Value, 0, len(m.removedchangelogs))
		for id := range m.removedchangelogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchangelogs {
		edges = append(edges, project.EdgeChangelogs)
	}
	if m.clearedrepo {
		edges = append(edges, project.EdgeRepo)
	}
	if m.clearednamespace {
		edges = append(edges, project.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeChangelogs:
		return m.clearedchangelogs
	case project.EdgeRepo:
		return m.clearedrepo
	case project.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeRepo:
		m.ClearRepo()
		return nil
	case project.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeChangelogs:
		m.ResetChangelogs()
		return nil
	case project.EdgeRepo:
		m.ResetRepo()
		return nil
	case project.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// RepoMutation represents an operation that mutates the Repo nodes in the graph.
type RepoMutation struct {
	config
	op                Op
	typ               string
	id                *int
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	default_branch    *string
	git_project_name  *string
	git_project_id    *int32
	addgit_project_id *int32
	enabled           *bool
	need_git_repo     *bool
	mars_config       **mars.Config
	description       *string
	clearedFields     map[string]struct{}
	projects          map[int]struct{}
	removedprojects   map[int]struct{}
	clearedprojects   bool
	done              bool
	oldValue          func(context.Context) (*Repo, error)
	predicates        []predicate.Repo
}

var _ ent.Mutation = (*RepoMutation)(nil)

// repoOption allows management of the mutation configuration using functional options.
type repoOption func(*RepoMutation)

// newRepoMutation creates new mutation for the Repo entity.
func newRepoMutation(c config, op Op, opts ...repoOption) *RepoMutation {
	m := &RepoMutation{
		config:        c,
		op:            op,
		typ:           TypeRepo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepoID sets the ID field of the mutation.
func withRepoID(id int) repoOption {
	return func(m *RepoMutation) {
		var (
			err   error
			once  sync.Once
			value *Repo
		)
		m.oldValue = func(ctx context.Context) (*Repo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepo sets the old Repo of the mutation.
func withRepo(node *Repo) repoOption {
	return func(m *RepoMutation) {
		m.oldValue = func(context.Context) (*Repo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepoMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepoMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Repo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RepoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RepoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RepoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RepoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RepoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RepoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RepoMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RepoMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RepoMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[repo.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RepoMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[repo.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RepoMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, repo.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *RepoMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RepoMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RepoMutation) ResetName() {
	m.name = nil
}

// SetDefaultBranch sets the "default_branch" field.
func (m *RepoMutation) SetDefaultBranch(s string) {
	m.default_branch = &s
}

// DefaultBranch returns the value of the "default_branch" field in the mutation.
func (m *RepoMutation) DefaultBranch() (r string, exists bool) {
	v := m.default_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultBranch returns the old "default_branch" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldDefaultBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultBranch: %w", err)
	}
	return oldValue.DefaultBranch, nil
}

// ClearDefaultBranch clears the value of the "default_branch" field.
func (m *RepoMutation) ClearDefaultBranch() {
	m.default_branch = nil
	m.clearedFields[repo.FieldDefaultBranch] = struct{}{}
}

// DefaultBranchCleared returns if the "default_branch" field was cleared in this mutation.
func (m *RepoMutation) DefaultBranchCleared() bool {
	_, ok := m.clearedFields[repo.FieldDefaultBranch]
	return ok
}

// ResetDefaultBranch resets all changes to the "default_branch" field.
func (m *RepoMutation) ResetDefaultBranch() {
	m.default_branch = nil
	delete(m.clearedFields, repo.FieldDefaultBranch)
}

// SetGitProjectName sets the "git_project_name" field.
func (m *RepoMutation) SetGitProjectName(s string) {
	m.git_project_name = &s
}

// GitProjectName returns the value of the "git_project_name" field in the mutation.
func (m *RepoMutation) GitProjectName() (r string, exists bool) {
	v := m.git_project_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGitProjectName returns the old "git_project_name" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldGitProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitProjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitProjectName: %w", err)
	}
	return oldValue.GitProjectName, nil
}

// ClearGitProjectName clears the value of the "git_project_name" field.
func (m *RepoMutation) ClearGitProjectName() {
	m.git_project_name = nil
	m.clearedFields[repo.FieldGitProjectName] = struct{}{}
}

// GitProjectNameCleared returns if the "git_project_name" field was cleared in this mutation.
func (m *RepoMutation) GitProjectNameCleared() bool {
	_, ok := m.clearedFields[repo.FieldGitProjectName]
	return ok
}

// ResetGitProjectName resets all changes to the "git_project_name" field.
func (m *RepoMutation) ResetGitProjectName() {
	m.git_project_name = nil
	delete(m.clearedFields, repo.FieldGitProjectName)
}

// SetGitProjectID sets the "git_project_id" field.
func (m *RepoMutation) SetGitProjectID(i int32) {
	m.git_project_id = &i
	m.addgit_project_id = nil
}

// GitProjectID returns the value of the "git_project_id" field in the mutation.
func (m *RepoMutation) GitProjectID() (r int32, exists bool) {
	v := m.git_project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGitProjectID returns the old "git_project_id" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldGitProjectID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGitProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGitProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGitProjectID: %w", err)
	}
	return oldValue.GitProjectID, nil
}

// AddGitProjectID adds i to the "git_project_id" field.
func (m *RepoMutation) AddGitProjectID(i int32) {
	if m.addgit_project_id != nil {
		*m.addgit_project_id += i
	} else {
		m.addgit_project_id = &i
	}
}

// AddedGitProjectID returns the value that was added to the "git_project_id" field in this mutation.
func (m *RepoMutation) AddedGitProjectID() (r int32, exists bool) {
	v := m.addgit_project_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearGitProjectID clears the value of the "git_project_id" field.
func (m *RepoMutation) ClearGitProjectID() {
	m.git_project_id = nil
	m.addgit_project_id = nil
	m.clearedFields[repo.FieldGitProjectID] = struct{}{}
}

// GitProjectIDCleared returns if the "git_project_id" field was cleared in this mutation.
func (m *RepoMutation) GitProjectIDCleared() bool {
	_, ok := m.clearedFields[repo.FieldGitProjectID]
	return ok
}

// ResetGitProjectID resets all changes to the "git_project_id" field.
func (m *RepoMutation) ResetGitProjectID() {
	m.git_project_id = nil
	m.addgit_project_id = nil
	delete(m.clearedFields, repo.FieldGitProjectID)
}

// SetEnabled sets the "enabled" field.
func (m *RepoMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *RepoMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *RepoMutation) ResetEnabled() {
	m.enabled = nil
}

// SetNeedGitRepo sets the "need_git_repo" field.
func (m *RepoMutation) SetNeedGitRepo(b bool) {
	m.need_git_repo = &b
}

// NeedGitRepo returns the value of the "need_git_repo" field in the mutation.
func (m *RepoMutation) NeedGitRepo() (r bool, exists bool) {
	v := m.need_git_repo
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedGitRepo returns the old "need_git_repo" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldNeedGitRepo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedGitRepo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedGitRepo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedGitRepo: %w", err)
	}
	return oldValue.NeedGitRepo, nil
}

// ResetNeedGitRepo resets all changes to the "need_git_repo" field.
func (m *RepoMutation) ResetNeedGitRepo() {
	m.need_git_repo = nil
}

// SetMarsConfig sets the "mars_config" field.
func (m *RepoMutation) SetMarsConfig(value *mars.Config) {
	m.mars_config = &value
}

// MarsConfig returns the value of the "mars_config" field in the mutation.
func (m *RepoMutation) MarsConfig() (r *mars.Config, exists bool) {
	v := m.mars_config
	if v == nil {
		return
	}
	return *v, true
}

// OldMarsConfig returns the old "mars_config" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldMarsConfig(ctx context.Context) (v *mars.Config, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarsConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarsConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarsConfig: %w", err)
	}
	return oldValue.MarsConfig, nil
}

// ClearMarsConfig clears the value of the "mars_config" field.
func (m *RepoMutation) ClearMarsConfig() {
	m.mars_config = nil
	m.clearedFields[repo.FieldMarsConfig] = struct{}{}
}

// MarsConfigCleared returns if the "mars_config" field was cleared in this mutation.
func (m *RepoMutation) MarsConfigCleared() bool {
	_, ok := m.clearedFields[repo.FieldMarsConfig]
	return ok
}

// ResetMarsConfig resets all changes to the "mars_config" field.
func (m *RepoMutation) ResetMarsConfig() {
	m.mars_config = nil
	delete(m.clearedFields, repo.FieldMarsConfig)
}

// SetDescription sets the "description" field.
func (m *RepoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *RepoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Repo entity.
// If the Repo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepoMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *RepoMutation) ResetDescription() {
	m.description = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *RepoMutation) AddProjectIDs(ids ...int) {
	if m.projects == nil {
		m.projects = make(map[int]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *RepoMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *RepoMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *RepoMutation) RemoveProjectIDs(ids ...int) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *RepoMutation) RemovedProjectsIDs() (ids []int) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *RepoMutation) ProjectsIDs() (ids []int) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *RepoMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// Where appends a list predicates to the RepoMutation builder.
func (m *RepoMutation) Where(ps ...predicate.Repo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Repo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Repo).
func (m *RepoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepoMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, repo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, repo.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, repo.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, repo.FieldName)
	}
	if m.default_branch != nil {
		fields = append(fields, repo.FieldDefaultBranch)
	}
	if m.git_project_name != nil {
		fields = append(fields, repo.FieldGitProjectName)
	}
	if m.git_project_id != nil {
		fields = append(fields, repo.FieldGitProjectID)
	}
	if m.enabled != nil {
		fields = append(fields, repo.FieldEnabled)
	}
	if m.need_git_repo != nil {
		fields = append(fields, repo.FieldNeedGitRepo)
	}
	if m.mars_config != nil {
		fields = append(fields, repo.FieldMarsConfig)
	}
	if m.description != nil {
		fields = append(fields, repo.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repo.FieldCreatedAt:
		return m.CreatedAt()
	case repo.FieldUpdatedAt:
		return m.UpdatedAt()
	case repo.FieldDeletedAt:
		return m.DeletedAt()
	case repo.FieldName:
		return m.Name()
	case repo.FieldDefaultBranch:
		return m.DefaultBranch()
	case repo.FieldGitProjectName:
		return m.GitProjectName()
	case repo.FieldGitProjectID:
		return m.GitProjectID()
	case repo.FieldEnabled:
		return m.Enabled()
	case repo.FieldNeedGitRepo:
		return m.NeedGitRepo()
	case repo.FieldMarsConfig:
		return m.MarsConfig()
	case repo.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case repo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case repo.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case repo.FieldName:
		return m.OldName(ctx)
	case repo.FieldDefaultBranch:
		return m.OldDefaultBranch(ctx)
	case repo.FieldGitProjectName:
		return m.OldGitProjectName(ctx)
	case repo.FieldGitProjectID:
		return m.OldGitProjectID(ctx)
	case repo.FieldEnabled:
		return m.OldEnabled(ctx)
	case repo.FieldNeedGitRepo:
		return m.OldNeedGitRepo(ctx)
	case repo.FieldMarsConfig:
		return m.OldMarsConfig(ctx)
	case repo.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Repo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case repo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case repo.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case repo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case repo.FieldDefaultBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultBranch(v)
		return nil
	case repo.FieldGitProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitProjectName(v)
		return nil
	case repo.FieldGitProjectID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGitProjectID(v)
		return nil
	case repo.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case repo.FieldNeedGitRepo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedGitRepo(v)
		return nil
	case repo.FieldMarsConfig:
		v, ok := value.(*mars.Config)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarsConfig(v)
		return nil
	case repo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Repo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepoMutation) AddedFields() []string {
	var fields []string
	if m.addgit_project_id != nil {
		fields = append(fields, repo.FieldGitProjectID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repo.FieldGitProjectID:
		return m.AddedGitProjectID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repo.FieldGitProjectID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGitProjectID(v)
		return nil
	}
	return fmt.Errorf("unknown Repo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(repo.FieldDeletedAt) {
		fields = append(fields, repo.FieldDeletedAt)
	}
	if m.FieldCleared(repo.FieldDefaultBranch) {
		fields = append(fields, repo.FieldDefaultBranch)
	}
	if m.FieldCleared(repo.FieldGitProjectName) {
		fields = append(fields, repo.FieldGitProjectName)
	}
	if m.FieldCleared(repo.FieldGitProjectID) {
		fields = append(fields, repo.FieldGitProjectID)
	}
	if m.FieldCleared(repo.FieldMarsConfig) {
		fields = append(fields, repo.FieldMarsConfig)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepoMutation) ClearField(name string) error {
	switch name {
	case repo.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case repo.FieldDefaultBranch:
		m.ClearDefaultBranch()
		return nil
	case repo.FieldGitProjectName:
		m.ClearGitProjectName()
		return nil
	case repo.FieldGitProjectID:
		m.ClearGitProjectID()
		return nil
	case repo.FieldMarsConfig:
		m.ClearMarsConfig()
		return nil
	}
	return fmt.Errorf("unknown Repo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepoMutation) ResetField(name string) error {
	switch name {
	case repo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case repo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case repo.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case repo.FieldName:
		m.ResetName()
		return nil
	case repo.FieldDefaultBranch:
		m.ResetDefaultBranch()
		return nil
	case repo.FieldGitProjectName:
		m.ResetGitProjectName()
		return nil
	case repo.FieldGitProjectID:
		m.ResetGitProjectID()
		return nil
	case repo.FieldEnabled:
		m.ResetEnabled()
		return nil
	case repo.FieldNeedGitRepo:
		m.ResetNeedGitRepo()
		return nil
	case repo.FieldMarsConfig:
		m.ResetMarsConfig()
		return nil
	case repo.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Repo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepoMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.projects != nil {
		edges = append(edges, repo.EdgeProjects)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repo.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprojects != nil {
		edges = append(edges, repo.EdgeProjects)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case repo.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprojects {
		edges = append(edges, repo.EdgeProjects)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepoMutation) EdgeCleared(name string) bool {
	switch name {
	case repo.EdgeProjects:
		return m.clearedprojects
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepoMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Repo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepoMutation) ResetEdge(name string) error {
	switch name {
	case repo.EdgeProjects:
		m.ResetProjects()
		return nil
	}
	return fmt.Errorf("unknown Repo edge %s", name)
}
